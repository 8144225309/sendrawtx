<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Broadcasting - sendrawtx</title>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
  background:#0f0f0f;color:#e0e0e0;min-height:100vh;display:flex;flex-direction:column;
  line-height:1.6;
}
a{color:#f7931a;text-decoration:none}
a:hover{text-decoration:underline}
code,.mono{font-family:'SF Mono',Consolas,'Liberation Mono',Menlo,monospace}
.container{max-width:1152px;margin:0 auto;padding:0 16px;width:100%}
@media(min-width:640px){.container{padding:0 24px}}

/* Header */
.header{position:sticky;top:0;z-index:50;background:rgba(15,15,15,.95);backdrop-filter:blur(8px);border-bottom:1px solid #1a1a1a}
.header-inner{display:flex;align-items:center;justify-content:space-between;height:64px}
.logo-link{display:flex;align-items:center;gap:8px}
.logo-link:hover{text-decoration:none}
.site-name{font-size:18px;font-weight:700;color:#fff;font-family:'SF Mono',Consolas,monospace}
.logo-link:hover .site-name{color:#f7931a}
nav{display:flex;align-items:center;gap:4px}
.nav-link{display:flex;align-items:center;gap:8px;padding:8px 16px;border-radius:8px;font-size:14px;font-weight:500;color:#a0a0a0;transition:all .15s}
.nav-link:hover{color:#fff;background:#1a1a1a;text-decoration:none}
.nav-link.active{color:#fff;background:#1a1a1a}
.nav-label{display:none}
@media(min-width:640px){.nav-label{display:inline}}

/* Cards */
.card{background:#1a1a1a;border:1px solid #333;border-radius:12px;padding:24px}
.card-sm{padding:16px}

/* Badge */
.badge{display:inline-flex;align-items:center;gap:4px;padding:2px 8px;border-radius:6px;font-size:12px;font-weight:600}
.badge-success{background:rgba(34,197,94,.15);color:#22c55e;border:1px solid rgba(34,197,94,.3)}
.badge-error{background:rgba(239,68,68,.15);color:#ef4444;border:1px solid rgba(239,68,68,.3)}
.badge-warning{background:rgba(234,179,8,.15);color:#eab308;border:1px solid rgba(234,179,8,.3)}
.badge-info{background:rgba(59,130,246,.15);color:#3b82f6;border:1px solid rgba(59,130,246,.3)}
.badge-orange{background:rgba(247,147,26,.15);color:#f7931a;border:1px solid rgba(247,147,26,.3)}
.badge-muted{background:#1a1a1a;color:#a0a0a0;border:1px solid #333}

/* Status */
.status-container{text-align:center;padding:48px 0 32px}
.status-icon{margin:0 auto 16px}
.status-title{font-size:24px;font-weight:700;color:#fff;margin-bottom:8px}
.status-sub{color:#a0a0a0;font-size:14px;margin-bottom:16px}
.status-links{display:flex;align-items:center;justify-content:center;gap:12px;flex-wrap:wrap}

/* Spinner */
@keyframes spin{to{transform:rotate(360deg)}}
.spinner{animation:spin 1s linear infinite}
.spinner-lg svg{width:48px;height:48px}

/* TX Preview */
.tx-preview{background:#1a1a1a;border:1px solid #333;border-radius:12px;overflow:hidden}
.tx-section-header{display:flex;align-items:center;justify-content:space-between;cursor:pointer;padding:12px 16px;background:#1f1f1f;border-bottom:1px solid #333;user-select:none}
.tx-section-header:hover{background:#252525}
.section-title{font-size:14px;font-weight:600;color:#fff;display:flex;align-items:center;gap:8px}
.tx-row{padding:10px 16px;border-bottom:1px solid #2a2a2a;font-size:13px}
.tx-row:last-child{border-bottom:none}
.tx-label{color:#888;font-size:12px;margin-bottom:2px}
.tx-value{color:#fff;font-family:'SF Mono',Consolas,monospace;font-size:13px;word-break:break-all}
.tx-info-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;padding:16px}
@media(min-width:640px){.tx-info-grid{grid-template-columns:repeat(4,1fr)}}
.tx-badges{display:flex;flex-wrap:wrap;gap:6px;padding:8px 16px}

/* Copy button */
.copy-btn{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border-radius:4px;font-size:12px;color:#a0a0a0;background:transparent;border:1px solid transparent;cursor:pointer;transition:all .15s}
.copy-btn:hover{color:#fff;background:#333;border-color:#444}
.copy-btn.copied{color:#22c55e}

/* Result summary */
.result-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:16px}
@media(min-width:640px){.result-grid{grid-template-columns:repeat(4,1fr)}}
.result-item{text-align:center}
.result-label{font-size:12px;color:#888;margin-bottom:4px}
.result-value{font-size:18px;font-weight:700;color:#fff}

/* Footer */
.footer{margin-top:auto;border-top:1px solid #1a1a1a;background:#0f0f0f;padding:32px 0}
.footer-inner{display:flex;flex-direction:column;align-items:center;gap:16px}
@media(min-width:640px){.footer-inner{flex-direction:row;justify-content:space-between}}
.footer-links{display:flex;align-items:center;gap:16px}
.footer-link{display:flex;align-items:center;gap:8px;font-size:14px;color:#a0a0a0;transition:color .15s}
.footer-link:hover{color:#fff;text-decoration:none}
.footer-credit{font-size:12px;color:#666;text-align:center;margin-top:24px;padding-top:24px;border-top:1px solid #1a1a1a}

/* Warning */
.warning-box{background:rgba(234,179,8,.1);border:1px solid rgba(234,179,8,.3);border-radius:8px;padding:12px 16px;display:flex;align-items:flex-start;gap:10px;margin:8px 16px}
.warning-text{color:#eab308;font-size:13px}

/* Protocol badges */
.protocol-badge{display:inline-flex;align-items:center;gap:4px;padding:2px 8px;border-radius:6px;font-size:11px;font-weight:600}

/* Expandable */
.expandable-content{display:none}
.expandable-content.open{display:block}

/* Error page */
.error-container{display:flex;align-items:center;justify-content:center;flex:1;padding:48px 16px}
.error-card{max-width:480px;text-align:center;width:100%}

/* Button */
.btn{display:inline-flex;align-items:center;gap:8px;padding:10px 20px;border-radius:8px;font-size:14px;font-weight:600;transition:all .15s}
.btn-primary{background:#f7931a;color:#000}
.btn-primary:hover{background:#ffa940;text-decoration:none}
.btn-muted{background:#1a1a1a;color:#a0a0a0;border:1px solid #333}
.btn-muted:hover{color:#fff;background:#252525;text-decoration:none}

/* Non-standard report */
.ns-check{padding:10px 16px;border-bottom:1px solid #2a2a2a;font-size:13px;display:flex;align-items:flex-start;gap:10px}
.ns-check:last-child{border-bottom:none}
.ns-detail{color:#888;font-size:12px;margin-top:2px}
.ns-limits{display:flex;gap:16px;margin-top:4px;font-size:11px;color:#666}

/* Acceptance bar */
.acceptance-bar{height:8px;border-radius:4px;background:#333;overflow:hidden;margin:8px 0}
.acceptance-fill{height:100%;border-radius:4px;background:#22c55e;transition:width .3s}

/* Endpoint list */
.endpoint-row{display:flex;align-items:center;justify-content:space-between;padding:8px 0;border-bottom:1px solid #2a2a2a;font-size:13px}
.endpoint-row:last-child{border-bottom:none}
.endpoint-name{display:flex;align-items:center;gap:8px}
.endpoint-time{color:#888;font-size:12px}
.network-banner{padding:8px 16px;text-align:center;font-size:13px;font-weight:600;letter-spacing:0.5px}
.network-banner-testnet{background:#7c3aed;color:#fff}
.network-banner-signet{background:#2563eb;color:#fff}
.network-banner-regtest{background:#059669;color:#fff}
</style>
</head>
<body>
<!-- NETWORK_BANNER -->

<!-- Header -->
<header class="header">
<div class="container header-inner">
  <a href="/" class="logo-link">
    <svg viewBox="0 0 100 100" style="width:56px;height:56px">
      <polygon points="50,2 93,26 93,74 50,98 7,74 7,26" fill="none" stroke="#f7931a" stroke-width="2" opacity="0.1"/>
      <polygon points="50,8 87,29 87,71 50,92 13,71 13,29" fill="none" stroke="#f7931a" stroke-width="2" opacity="0.2"/>
      <polygon points="50,14 81,32 81,68 50,86 19,68 19,32" fill="none" stroke="#f7931a" stroke-width="2" opacity="0.35"/>
      <polygon points="50,20 75,35 75,65 50,80 25,65 25,35" fill="none" stroke="#f7931a" stroke-width="2" opacity="0.55"/>
      <polygon points="50,26 69,38 69,62 50,74 31,62 31,38" fill="none" stroke="#f7931a" stroke-width="2.5" opacity="0.8"/>
      <text x="50" y="58" text-anchor="middle" font-size="20" font-weight="bold" fill="#f7931a" font-family="Georgia,serif">TX</text>
    </svg>
    <span class="site-name" id="siteName"></span>
  </a>
  <nav>
    <a href="/" class="nav-link active"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg><span class="nav-label">Broadcast</span></a>
    <a href="/docs" class="nav-link"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg><span class="nav-label">API Docs</span></a>
    <a href="/status" class="nav-link"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg><span class="nav-label">Status</span></a>
  </nav>
</div>
</header>

<!-- Main Content -->
<main style="flex:1">
<div style="max-width:896px;margin:0 auto;padding:32px 16px">

  <!-- Status Section -->
  <div id="statusSection" class="status-container">
    <div id="statusIcon" class="status-icon spinner-lg">
      <svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="#f7931a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="spinner"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>
    </div>
    <h1 id="statusTitle" class="status-title">Broadcasting Transaction</h1>
    <p id="statusSub" class="status-sub">Submitting to network endpoints...</p>
    <div id="statusLinks" class="status-links" style="display:none"></div>
  </div>

  <!-- Error Section (hidden by default) -->
  <div id="errorSection" class="error-container" style="display:none">
    <div class="card error-card">
      <svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin:0 auto 16px;display:block"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>
      <h2 style="font-size:20px;font-weight:600;color:#fff;margin-bottom:8px">Invalid Transaction</h2>
      <p id="errorMessage" style="color:#a0a0a0;margin-bottom:16px"></p>
      <a href="/" style="display:inline-flex;align-items:center;gap:8px;color:#f7931a;font-size:14px">Back to Broadcast</a>
    </div>
  </div>

  <!-- Dynamic Network Detection Banner -->
  <div id="chain-detect-banner" style="display:none;margin-bottom:16px;padding:10px 16px;border-radius:8px;font-size:13px;font-weight:500;text-align:center"></div>

  <!-- Transaction Preview -->
  <div id="txPreviewSection" style="display:none;margin-bottom:32px">
    <div id="txPreview"></div>
  </div>

  <!-- Result Summary -->
  <div id="resultSection" style="display:none;margin-bottom:24px">
    <div class="card">
      <div id="resultGrid" class="result-grid"></div>
    </div>
  </div>

  <!-- Endpoint Results -->
  <div id="endpointSection" style="display:none;margin-bottom:24px">
    <h2 style="font-size:16px;font-weight:600;color:#fff;margin-bottom:12px">Endpoint Acceptance</h2>
    <div class="card card-sm">
      <div id="acceptanceBar"></div>
      <div id="endpointList"></div>
    </div>
  </div>

</div>
</main>

<!-- Footer -->
<footer class="footer">
<div class="container">
  <div class="footer-inner">
    <div>
      <p style="font-size:14px;color:#a0a0a0"><span style="color:#fff;font-weight:500" class="mono" id="footerSiteName"></span> - Bitcoin raw transaction broadcast service</p>
      <p style="font-size:12px;color:#666;margin-top:4px">Specializing in non-standard transactions that other services reject</p>
    </div>
    <div class="footer-links">
      <a href="https://github.com/8144225309/sendrawtx" target="_blank" rel="noopener noreferrer" class="footer-link">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        <span>GitHub</span>
      </a>
      <a href="https://mempool.space" target="_blank" rel="noopener noreferrer" class="footer-link">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
        <span>mempool.space</span>
      </a>
    </div>
  </div>
  <div class="footer-credit">Built with Bitcoin Core, Knots, and Libre Relay</div>
</div>
</footer>

<script>
/**
 * Pure JavaScript Bitcoin Transaction Decoder
 * No external dependencies - just byte parsing and math
 * Converted from TypeScript - original had zero npm dependencies
 */
const TxDecoder = (function() {
'use strict';

// ============================================================================
// Standard limits from Bitcoin Core policy.h
// ============================================================================

const LIMITS = {
  MIN_TX_SIZE: 82,                    // Minimum non-witness size
  MAX_STANDARD_TX_WEIGHT: 400000,     // 100 kvB
  MAX_STANDARD_VERSION: 2,
  MAX_OP_RETURN_RELAY: 83,            // OP_RETURN max size
  MAX_OP_RETURN_COUNT: 1,             // Only 1 OP_RETURN allowed
  MAX_SCRIPTSIG_SIZE: 1650,           // ~15-of-15 multisig
  MAX_STANDARD_P2WSH_SCRIPT_SIZE: 3600,
  MAX_STANDARD_P2WSH_STACK_ITEMS: 100,
  MAX_BARE_MULTISIG_PUBKEYS: 3,
  // Dust limits at 3000 sat/kvB
  DUST_P2PKH: 546,
  DUST_P2WPKH: 294,
  DUST_P2TR: 330,
  DUST_P2SH: 540,
  DUST_P2WSH: 330,
};

// ============================================================================
// Hex/Byte Utilities
// ============================================================================

class ByteReader {
  constructor(hex) {
    this.hex = hex.toLowerCase().replace(/\s/g, '');
    this.pos = 0;
  }

  get position() {
    return this.pos;
  }

  get remaining() {
    return (this.hex.length - this.pos) / 2;
  }

  get totalBytes() {
    return this.hex.length / 2;
  }

  readBytes(n) {
    if (this.pos + n * 2 > this.hex.length) {
      throw new Error(`Not enough bytes: need ${n}, have ${this.remaining}`);
    }
    const result = this.hex.slice(this.pos, this.pos + n * 2);
    this.pos += n * 2;
    return result;
  }

  readUInt8() {
    return parseInt(this.readBytes(1), 16);
  }

  readUInt16LE() {
    const bytes = this.readBytes(2);
    return parseInt(bytes.slice(2, 4) + bytes.slice(0, 2), 16);
  }

  readUInt32LE() {
    const bytes = this.readBytes(4);
    return parseInt(
      bytes.slice(6, 8) + bytes.slice(4, 6) +
      bytes.slice(2, 4) + bytes.slice(0, 2),
      16
    );
  }

  readUInt64LE() {
    const bytes = this.readBytes(8);
    let result = 0n;
    for (let i = 7; i >= 0; i--) {
      result = result * 256n + BigInt(parseInt(bytes.slice(i * 2, i * 2 + 2), 16));
    }
    return result;
  }

  readVarInt() {
    const first = this.readUInt8();
    if (first < 0xfd) return first;
    if (first === 0xfd) return this.readUInt16LE();
    if (first === 0xfe) return this.readUInt32LE();
    // 0xff - 8 byte int (rarely used for counts)
    return Number(this.readUInt64LE());
  }

  readHash256() {
    // Read 32 bytes and reverse for display (Bitcoin shows txids reversed)
    const bytes = this.readBytes(32);
    return reverseHex(bytes);
  }

  peek(n) {
    return this.hex.slice(this.pos, this.pos + n * 2);
  }
}

function reverseHex(hex) {
  const bytes = hex.match(/.{2}/g) || [];
  return bytes.reverse().join('');
}

function hexToAscii(hex) {
  let result = '';
  for (let i = 0; i < hex.length; i += 2) {
    const code = parseInt(hex.slice(i, i + 2), 16);
    // Only include printable ASCII characters
    if (code >= 32 && code < 127) {
      result += String.fromCharCode(code);
    } else {
      result += '.';
    }
  }
  return result;
}

function satsToBtc(sats) {
  return (sats / 100_000_000).toFixed(8);
}

// ============================================================================
// Bech32/Bech32m Encoding (Pure math - no crypto needed)
// ============================================================================

const BECH32_CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

const BECH32_GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];

function bech32Polymod(values) {
  let chk = 1;
  for (const v of values) {
    const top = chk >> 25;
    chk = ((chk & 0x1ffffff) << 5) ^ v;
    for (let i = 0; i < 5; i++) {
      if ((top >> i) & 1) {
        chk ^= BECH32_GENERATOR[i];
      }
    }
  }
  return chk;
}

function bech32HrpExpand(hrp) {
  const result = [];
  for (const c of hrp) {
    result.push(c.charCodeAt(0) >> 5);
  }
  result.push(0);
  for (const c of hrp) {
    result.push(c.charCodeAt(0) & 31);
  }
  return result;
}

function bech32CreateChecksum(hrp, data, isBech32m) {
  const values = bech32HrpExpand(hrp).concat(data);
  const CONST = isBech32m ? 0x2bc830a3 : 1;
  const polymod = bech32Polymod(values.concat([0, 0, 0, 0, 0, 0])) ^ CONST;
  const checksum = [];
  for (let i = 0; i < 6; i++) {
    checksum.push((polymod >> (5 * (5 - i))) & 31);
  }
  return checksum;
}

function convertBits(data, fromBits, toBits, pad) {
  let acc = 0;
  let bits = 0;
  const result = [];
  const maxv = (1 << toBits) - 1;

  for (const value of data) {
    if (value < 0 || value >> fromBits !== 0) return null;
    acc = (acc << fromBits) | value;
    bits += fromBits;
    while (bits >= toBits) {
      bits -= toBits;
      result.push((acc >> bits) & maxv);
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push((acc << (toBits - bits)) & maxv);
    }
  } else if (bits >= fromBits || ((acc << (toBits - bits)) & maxv) !== 0) {
    return null;
  }

  return result;
}

function encodeBech32(hrp, version, program, isBech32m) {
  const data = [version].concat(convertBits(program, 8, 5, true) || []);
  const checksum = bech32CreateChecksum(hrp, data, isBech32m);
  let result = hrp + '1';
  for (const d of data.concat(checksum)) {
    result += BECH32_CHARSET[d];
  }
  return result;
}

function encodeSegwitAddress(hrp, version, program) {
  const programBytes = [];
  for (let i = 0; i < program.length; i += 2) {
    programBytes.push(parseInt(program.slice(i, i + 2), 16));
  }
  // Bech32m for version 1+ (taproot), Bech32 for version 0
  const isBech32m = version > 0;
  return encodeBech32(hrp, version, programBytes, isBech32m);
}

// ============================================================================
// Base58Check Encoding (needs SHA256 from browser crypto)
// ============================================================================

const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

function base58Encode(bytes) {
  // Count leading zeros
  let zeros = 0;
  for (const b of bytes) {
    if (b === 0) zeros++;
    else break;
  }

  // Convert to base58
  const digits = [0];
  for (const byte of bytes) {
    let carry = byte;
    for (let i = 0; i < digits.length; i++) {
      carry += digits[i] << 8;
      digits[i] = carry % 58;
      carry = Math.floor(carry / 58);
    }
    while (carry > 0) {
      digits.push(carry % 58);
      carry = Math.floor(carry / 58);
    }
  }

  // Build string
  let result = '';
  for (let i = 0; i < zeros; i++) result += '1';
  for (let i = digits.length - 1; i >= 0; i--) {
    result += BASE58_ALPHABET[digits[i]];
  }

  return result;
}

async function sha256(data) {
  // Create a fresh ArrayBuffer to avoid SharedArrayBuffer issues
  let buffer;
  if (data instanceof Uint8Array) {
    buffer = new ArrayBuffer(data.length);
    new Uint8Array(buffer).set(data);
  } else {
    buffer = data;
  }
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  return new Uint8Array(hashBuffer);
}

async function doubleSha256(data) {
  return sha256(await sha256(data));
}

async function encodeBase58Check(version, hash) {
  const hashBytes = new Uint8Array(hash.length / 2);
  for (let i = 0; i < hash.length; i += 2) {
    hashBytes[i / 2] = parseInt(hash.slice(i, i + 2), 16);
  }

  const payload = new Uint8Array(1 + hashBytes.length);
  payload[0] = version;
  payload.set(hashBytes, 1);

  const checksum = await doubleSha256(payload);

  const result = new Uint8Array(payload.length + 4);
  result.set(payload);
  result.set(checksum.slice(0, 4), payload.length);

  return base58Encode(result);
}

// ============================================================================
// Script Analysis
// ============================================================================

function identifyScriptType(scriptPubKey) {
  const len = scriptPubKey.length / 2;

  // OP_RETURN (0x6a)
  if (scriptPubKey.startsWith('6a')) {
    return { type: 'op_return', data: scriptPubKey.slice(2) };
  }

  // P2PKH: OP_DUP OP_HASH160 <20 bytes> OP_EQUALVERIFY OP_CHECKSIG
  // 76 a9 14 <pubkeyhash:20> 88 ac
  if (len === 25 && scriptPubKey.startsWith('76a914') && scriptPubKey.endsWith('88ac')) {
    return { type: 'p2pkh', data: scriptPubKey.slice(6, 46) };
  }

  // P2SH: OP_HASH160 <20 bytes> OP_EQUAL
  // a9 14 <scripthash:20> 87
  if (len === 23 && scriptPubKey.startsWith('a914') && scriptPubKey.endsWith('87')) {
    return { type: 'p2sh', data: scriptPubKey.slice(4, 44) };
  }

  // P2WPKH: OP_0 <20 bytes>
  // 00 14 <pubkeyhash:20>
  if (len === 22 && scriptPubKey.startsWith('0014')) {
    return { type: 'p2wpkh', data: scriptPubKey.slice(4) };
  }

  // P2WSH: OP_0 <32 bytes>
  // 00 20 <scripthash:32>
  if (len === 34 && scriptPubKey.startsWith('0020')) {
    return { type: 'p2wsh', data: scriptPubKey.slice(4) };
  }

  // P2TR: OP_1 <32 bytes>
  // 51 20 <tweaked_pubkey:32>
  if (len === 34 && scriptPubKey.startsWith('5120')) {
    return { type: 'p2tr', data: scriptPubKey.slice(4) };
  }

  // P2PK: <pubkey> OP_CHECKSIG
  // Compressed: 21 <pubkey:33> ac
  // Uncompressed: 41 <pubkey:65> ac
  if ((len === 35 && scriptPubKey.startsWith('21') && scriptPubKey.endsWith('ac')) ||
      (len === 67 && scriptPubKey.startsWith('41') && scriptPubKey.endsWith('ac'))) {
    return { type: 'p2pk', data: scriptPubKey.slice(2, -2) };
  }

  // Check for bare multisig (starts with OP_1-OP_16, contains pubkeys, ends with OP_CHECKMULTISIG)
  const firstByte = parseInt(scriptPubKey.slice(0, 2), 16);
  if (firstByte >= 0x51 && firstByte <= 0x60 && scriptPubKey.endsWith('ae')) {
    return { type: 'multisig' };
  }

  return { type: 'unknown' };
}

function parseOpReturnData(data) {
  // Skip length prefix if present
  let payload = data;
  const firstByte = parseInt(data.slice(0, 2), 16);

  // Handle push opcodes
  if (firstByte <= 0x4b) {
    // Direct push
    payload = data.slice(2);
  } else if (firstByte === 0x4c) {
    // OP_PUSHDATA1
    payload = data.slice(4);
  } else if (firstByte === 0x4d) {
    // OP_PUSHDATA2
    payload = data.slice(6);
  } else if (firstByte === 0x4e) {
    // OP_PUSHDATA4
    payload = data.slice(10);
  }

  return {
    hex: payload,
    ascii: hexToAscii(payload)
  };
}

async function scriptToAddress(scriptType, data, isMainnet) {
  var net = window.__NETWORK__ || 'mainnet';
  if (isMainnet === undefined) isMainnet = (net === 'mainnet');
  var hrp = net === 'regtest' ? 'bcrt' : (isMainnet ? 'bc' : 'tb');

  switch (scriptType) {
    case 'p2wpkh':
      return encodeSegwitAddress(hrp, 0, data);

    case 'p2wsh':
      return encodeSegwitAddress(hrp, 0, data);

    case 'p2tr':
      return encodeSegwitAddress(hrp, 1, data);

    case 'p2pkh':
      // Version 0x00 for mainnet, 0x6f for testnet
      return encodeBase58Check(isMainnet ? 0x00 : 0x6f, data);

    case 'p2sh':
      // Version 0x05 for mainnet, 0xc4 for testnet
      return encodeBase58Check(isMainnet ? 0x05 : 0xc4, data);

    default:
      return undefined;
  }
}

function disassembleScript(script) {
  const OPCODES = {
    0x00: 'OP_0', 0x4c: 'OP_PUSHDATA1', 0x4d: 'OP_PUSHDATA2', 0x4e: 'OP_PUSHDATA4',
    0x4f: 'OP_1NEGATE', 0x51: 'OP_1', 0x52: 'OP_2', 0x53: 'OP_3', 0x54: 'OP_4',
    0x55: 'OP_5', 0x56: 'OP_6', 0x57: 'OP_7', 0x58: 'OP_8', 0x59: 'OP_9',
    0x5a: 'OP_10', 0x5b: 'OP_11', 0x5c: 'OP_12', 0x5d: 'OP_13', 0x5e: 'OP_14',
    0x5f: 'OP_15', 0x60: 'OP_16',
    0x76: 'OP_DUP', 0x87: 'OP_EQUAL', 0x88: 'OP_EQUALVERIFY',
    0xa9: 'OP_HASH160', 0xac: 'OP_CHECKSIG', 0xae: 'OP_CHECKMULTISIG',
    0x6a: 'OP_RETURN', 0x75: 'OP_DROP',
  };

  const parts = [];
  let i = 0;

  while (i < script.length) {
    const opcode = parseInt(script.slice(i, i + 2), 16);
    i += 2;

    if (opcode === 0) {
      parts.push('OP_0');
    } else if (opcode >= 1 && opcode <= 0x4b) {
      // Direct push
      const data = script.slice(i, i + opcode * 2);
      i += opcode * 2;
      parts.push(data);
    } else if (opcode === 0x4c) {
      // OP_PUSHDATA1
      const len = parseInt(script.slice(i, i + 2), 16);
      i += 2;
      const data = script.slice(i, i + len * 2);
      i += len * 2;
      parts.push(data);
    } else if (OPCODES[opcode]) {
      parts.push(OPCODES[opcode]);
    } else {
      parts.push(`OP_UNKNOWN_${opcode.toString(16)}`);
    }
  }

  return parts.join(' ');
}

// ============================================================================
// LEB128 Varint Decoder (for Runes protocol)
// ============================================================================

/**
 * Decode an unsigned LEB128 varint from a byte array
 * Used by the Runes protocol for compact integer encoding
 */
function decodeLEB128(bytes, offset) {
  let result = 0n;
  let shift = 0n;
  let bytesRead = 0;

  while (offset + bytesRead < bytes.length) {
    const byte = bytes[offset + bytesRead];
    result |= BigInt(byte & 0x7f) << shift;
    bytesRead++;
    if ((byte & 0x80) === 0) break;
    shift += 7n;
  }

  return { value: result, bytesRead };
}

/**
 * Decode a sequence of LEB128 varints from a byte array
 */
function decodeAllLEB128(bytes) {
  const values = [];
  let offset = 0;

  while (offset < bytes.length) {
    const { value, bytesRead } = decodeLEB128(bytes, offset);
    values.push(value);
    offset += bytesRead;
    if (bytesRead === 0) break; // Safety check
  }

  return values;
}

// ============================================================================
// Ordinals Envelope Parser
// ============================================================================

/**
 * Parse a hex string to Uint8Array
 */
function hexToBytes(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}

/**
 * Parse Ordinals envelope from witness data
 *
 * Envelope structure:
 * OP_FALSE (0x00)
 * OP_IF (0x63)
 * "ord" (0x036f7264)
 * [tag] [data]...
 *   Tag 1 = content-type
 *   Tag 3 = parent (TXID:INDEX)
 *   Tag 5 = pointer
 *   Tag 7 = metadata (CBOR)
 *   Tag 9 = metaprotocol
 *   Tag 0 = content (empty tag marks content start)
 * OP_ENDIF (0x68)
 */
function parseOrdinalsEnvelope(witness) {
  if (!witness || witness.length === 0) return null;

  // Ordinals inscriptions are typically in the second-to-last witness item for taproot
  // Look through all witness items for the envelope
  for (const item of witness) {
    const itemLower = item.toLowerCase();

    // Look for the envelope marker: OP_FALSE OP_IF "ord"
    // Pattern: 0063 + 03 + 6f7264 (OP_0 OP_IF PUSH3 "ord")
    const envelopeStart = itemLower.indexOf('0063036f7264');
    if (envelopeStart === -1) continue;

    try {
      const bytes = hexToBytes(itemLower);
      const startOffset = envelopeStart / 2 + 6; // Skip OP_0 OP_IF PUSH3 "ord"

      let contentType = '';
      let content = new Uint8Array(0);
      let pointer;
      let parent;
      let metaprotocol;
      let metadata;

      let i = startOffset;

      // Parse tag-value pairs until we hit OP_ENDIF (0x68) or end
      while (i < bytes.length) {
        const opcode = bytes[i];

        // OP_ENDIF marks the end
        if (opcode === 0x68) break;

        // OP_0 marks content start (tag 0)
        if (opcode === 0x00) {
          i++;
          // Collect all remaining push data as content
          const contentParts = [];
          while (i < bytes.length && bytes[i] !== 0x68) {
            const pushLen = bytes[i];
            if (pushLen === 0x00) {
              i++;
              continue;
            }
            if (pushLen <= 0x4b) {
              // Direct push (1-75 bytes)
              i++;
              for (let j = 0; j < pushLen && i < bytes.length && bytes[i] !== 0x68; j++, i++) {
                contentParts.push(bytes[i]);
              }
            } else if (pushLen === 0x4c) {
              // OP_PUSHDATA1
              const len = bytes[i + 1] || 0;
              i += 2;
              for (let j = 0; j < len && i < bytes.length && bytes[i] !== 0x68; j++, i++) {
                contentParts.push(bytes[i]);
              }
            } else if (pushLen === 0x4d) {
              // OP_PUSHDATA2
              const len = (bytes[i + 1] || 0) | ((bytes[i + 2] || 0) << 8);
              i += 3;
              for (let j = 0; j < len && i < bytes.length && bytes[i] !== 0x68; j++, i++) {
                contentParts.push(bytes[i]);
              }
            } else {
              // Non-push opcode or OP_ENDIF - stop
              break;
            }
          }
          content = new Uint8Array(contentParts);
          continue;
        }

        // Read tag (small push)
        let tag = 0;
        if (opcode >= 0x01 && opcode <= 0x10) {
          // OP_1 to OP_16
          tag = opcode - 0x50;
          i++;
        } else if (opcode >= 0x51 && opcode <= 0x60) {
          // OP_1 to OP_16 (alternative encoding)
          tag = opcode - 0x50;
          i++;
        } else {
          i++;
          continue;
        }

        // Read data push
        if (i >= bytes.length) break;
        const dataLen = bytes[i];
        if (dataLen > 0x4b || i + 1 + dataLen > bytes.length) {
          i++;
          continue;
        }
        i++;
        const data = bytes.slice(i, i + dataLen);
        i += dataLen;

        // Process tag
        switch (tag) {
          case 1: // content-type
            contentType = new TextDecoder().decode(data);
            break;
          case 3: // parent
            if (data.length >= 32) {
              const parentTxid = Array.from(data.slice(0, 32))
                .reverse()
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
              const parentIndex = data.length > 32 ? data[32] : 0;
              parent = `${parentTxid}i${parentIndex}`;
            }
            break;
          case 5: // pointer
            if (data.length > 0) {
              pointer = data[0];
              for (let j = 1; j < data.length; j++) {
                pointer |= data[j] << (j * 8);
              }
            }
            break;
          case 7: // metadata (CBOR - just store raw for now)
            // Basic CBOR parsing could be added here
            break;
          case 9: // metaprotocol
            metaprotocol = new TextDecoder().decode(data);
            break;
        }
      }

      if (!contentType && content.length === 0) continue;

      // Generate content preview
      let contentPreview = '';
      if (contentType.startsWith('text/') || contentType === 'application/json') {
        // Text content - show as string
        try {
          const text = new TextDecoder().decode(content);
          contentPreview = text.length > 200 ? text.slice(0, 200) + '...' : text;
        } catch {
          contentPreview = Array.from(content.slice(0, 64))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
        }
      } else {
        // Binary content - show hex preview
        contentPreview = Array.from(content.slice(0, 64))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
        if (content.length > 64) contentPreview += '...';
      }

      return {
        contentType: contentType || 'application/octet-stream',
        contentLength: content.length,
        content,
        contentPreview,
        pointer,
        parent,
        metadata,
        metaprotocol,
      };
    } catch {
      continue;
    }
  }

  return null;
}

// ============================================================================
// BRC-20 Parser
// ============================================================================

/**
 * Parse and validate BRC-20 JSON operation
 */
function parseBRC20(json) {
  try {
    const obj = JSON.parse(json);

    // Must have p = "brc-20"
    if (obj.p !== 'brc-20') return null;

    // Validate op
    const validOps = ['deploy', 'mint', 'transfer'];
    if (!validOps.includes(obj.op)) return null;

    // Validate tick (should be 4 bytes for standard, but some use more)
    if (!obj.tick || typeof obj.tick !== 'string' || obj.tick.length < 1) {
      return null;
    }

    const result = {
      op: obj.op,
      tick: obj.tick,
    };

    // Validate and add optional fields
    if (obj.amt !== undefined) {
      // Amount should be a positive number string
      if (typeof obj.amt === 'string' && /^\d+(\.\d+)?$/.test(obj.amt)) {
        result.amt = obj.amt;
      }
    }

    if (obj.max !== undefined && typeof obj.max === 'string') {
      result.max = obj.max;
    }

    if (obj.lim !== undefined && typeof obj.lim === 'string') {
      result.lim = obj.lim;
    }

    if (obj.dec !== undefined) {
      result.dec = String(obj.dec);
    }

    return result;
  } catch {
    return null;
  }
}

/**
 * Extract BRC-20 data from inscription content
 */
function detectBrc20FromInscription(inscription) {
  // BRC-20 must have JSON content type
  if (!inscription.contentType.includes('json') && !inscription.contentType.includes('text/plain')) {
    return null;
  }

  try {
    const text = new TextDecoder().decode(inscription.content);
    return parseBRC20(text);
  } catch {
    return null;
  }
}

// ============================================================================
// Runes Protocol Decoder
// ============================================================================

// Runes Tag constants (from mempool.space implementation)
const RuneTag = {
  Body: 0,
  Flags: 2,
  Rune: 4,
  Premine: 6,
  Cap: 8,
  Amount: 10,
  HeightStart: 12,
  HeightEnd: 14,
  OffsetStart: 16,
  OffsetEnd: 18,
  Mint: 20,
  Pointer: 22,
  Cenotaph: 126,
  // Odd tags
  Divisibility: 1,
  Spacers: 3,
  Symbol: 5,
  Nop: 127,
};

// Runes Flag bits
const RuneFlag = {
  ETCHING: 1n,
  TERMS: 1n << 1n,
  TURBO: 1n << 2n,
  CENOTAPH: 1n << 127n,
};

// Runes alphabet for name encoding (A-Z)
const RUNES_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

/**
 * Decode a Rune name from its numeric representation
 * Based on mempool.space implementation
 */
function decodeRuneName(rune) {
  let name = '';
  rune += 1n; // Add 1 first (mempool.space approach)
  while (rune > 0n) {
    name = RUNES_ALPHABET[Number((rune - 1n) % 26n)] + name;
    rune = (rune - 1n) / 26n;
  }
  return name || 'A';
}

/**
 * Apply spacers to a rune name using bitwise flags
 * Based on mempool.space implementation
 */
function applySpacers(name, spacers) {
  if (spacers === 0n) return name;

  let result = '';
  let spacerBits = spacers;
  for (let i = 0; i < name.length; i++) {
    result += name[i];
    if (spacerBits & 1n) {
      result += '\u2022';
    }
    if (spacerBits > 0n) {
      spacerBits >>= 1n;
    }
  }
  return result;
}

/**
 * Parse tag-value pairs from LEB128 integers into a message structure
 * Based on mempool.space implementation
 */
function integersToMessage(integers) {
  const fields = new Map();
  const edicts = [];
  let inBody = false;
  let i = 0;

  while (i < integers.length) {
    if (!inBody) {
      const tag = Number(integers[i++]);
      if (tag === RuneTag.Body) {
        inBody = true;
      } else if (i < integers.length) {
        const value = integers[i++];
        const existing = fields.get(tag);
        if (existing) {
          existing.push(value);
        } else {
          fields.set(tag, [value]);
        }
      }
    } else {
      // Edicts: block height, tx index, amount, output
      if (i + 3 < integers.length) {
        const height = integers[i++];
        const txIndex = integers[i++];
        const amount = integers[i++];
        const output = Number(integers[i++]);
        edicts.push({
          id: { block: Number(height), tx: Number(txIndex) },
          amount,
          output,
        });
      } else {
        break;
      }
    }
    // Safety limit
    if (edicts.length > 100) break;
  }

  return { fields, edicts };
}

/**
 * Parse Runes protocol payload from OP_RETURN data
 * Based on mempool.space implementation
 *
 * Structure:
 * OP_RETURN (0x6a)
 * OP_13 (0x5d) - Runes magic number
 * [payload as LEB128-encoded integers]
 */
function parseRunesPayload(opReturnData) {
  try {
    // Decode all LEB128 values
    const integers = decodeAllLEB128(opReturnData);
    if (integers.length === 0) return null;

    // Parse into message structure
    const message = integersToMessage(integers);
    const fields = message.fields;

    // Get flags
    const flagsValue = fields.get(RuneTag.Flags)?.[0] ?? 0n;
    const hasEtching = (flagsValue & RuneFlag.ETCHING) > 0n;
    const hasTerms = (flagsValue & RuneFlag.TERMS) > 0n;
    const hasTurbo = (flagsValue & RuneFlag.TURBO) > 0n;
    const isCenotaph = fields.has(RuneTag.Cenotaph) || (flagsValue & RuneFlag.CENOTAPH) > 0n;

    const result = {
      type: hasEtching ? 'etching' : 'transfer',
      edicts: message.edicts,
      flags: Number(flagsValue),
      cenotaph: isCenotaph || undefined,
    };

    // Parse etching if present
    if (hasEtching) {
      // Decode rune name
      const runeValue = fields.get(RuneTag.Rune)?.[0];
      if (runeValue !== undefined) {
        result.runeName = decodeRuneName(runeValue);
      }

      // Divisibility
      const divisibility = fields.get(RuneTag.Divisibility)?.[0];
      if (divisibility !== undefined) {
        result.divisibility = Number(divisibility);
      }

      // Premine
      const premine = fields.get(RuneTag.Premine)?.[0];
      if (premine !== undefined) {
        result.premine = premine;
      }

      // Symbol
      const symbolCode = fields.get(RuneTag.Symbol)?.[0];
      if (symbolCode !== undefined && symbolCode > 0n && symbolCode < 0x10FFFFn) {
        result.symbol = String.fromCodePoint(Number(symbolCode));
      } else {
        result.symbol = '\u00a4'; // Default symbol
      }

      // Spacers
      const spacers = fields.get(RuneTag.Spacers)?.[0];
      if (spacers !== undefined) {
        result.spacers = Number(spacers);
        if (result.runeName) {
          result.spacedName = applySpacers(result.runeName, spacers);
        }
      } else {
        result.spacedName = result.runeName;
      }

      // Turbo mode
      result.turbo = hasTurbo;

      // Parse terms if present
      if (hasTerms) {
        result.terms = {};

        const cap = fields.get(RuneTag.Cap)?.[0];
        if (cap !== undefined) result.terms.cap = cap;

        const amount = fields.get(RuneTag.Amount)?.[0];
        if (amount !== undefined) result.terms.amount = amount;

        const heightStart = fields.get(RuneTag.HeightStart)?.[0];
        const heightEnd = fields.get(RuneTag.HeightEnd)?.[0];
        if (heightStart !== undefined || heightEnd !== undefined) {
          result.terms.height = { start: heightStart, end: heightEnd };
        }

        const offsetStart = fields.get(RuneTag.OffsetStart)?.[0];
        const offsetEnd = fields.get(RuneTag.OffsetEnd)?.[0];
        if (offsetStart !== undefined || offsetEnd !== undefined) {
          result.terms.offset = { start: offsetStart, end: offsetEnd };
        }
      }

      // Calculate supply: (cap * amount) + premine
      const termsCap = result.terms?.cap ?? 0n;
      const termsAmount = result.terms?.amount ?? 0n;
      const premineAmount = result.premine ?? 0n;
      result.supply = (termsCap * termsAmount) + premineAmount;
    }

    // Check for mint operation
    const mintField = fields.get(RuneTag.Mint);
    if (mintField && mintField.length >= 2) {
      result.runeId = { block: Number(mintField[0]), tx: Number(mintField[1]) };
      if (!hasEtching) {
        result.type = 'mint';
      }
    }

    // Determine final type
    if (hasEtching && result.runeName) {
      result.type = 'etching';
    } else if (result.runeId) {
      result.type = 'mint';
    } else if (result.edicts.length > 0) {
      result.type = 'transfer';
    }

    return result;
  } catch {
    return null;
  }
}

// ============================================================================
// CAT-21 Detection
// ============================================================================

/**
 * Detect CAT-21 from inscription content
 * CAT-21 uses Ordinals inscriptions with JSON content containing "p": "cat-21"
 */
function detectCAT21(inscription) {
  // CAT-21 uses JSON content type
  if (!inscription.contentType.includes('json') && !inscription.contentType.includes('text/plain')) {
    return null;
  }

  try {
    const text = new TextDecoder().decode(inscription.content);
    const obj = JSON.parse(text);

    // Check for CAT-21 protocol marker
    if (obj.p === 'cat-21' || obj.protocol === 'cat-21') {
      return {
        type: obj.op === 'mint' || obj.type === 'genesis' ? 'genesis' : 'transfer',
        catId: obj.id || obj.catId,
      };
    }

    return null;
  } catch {
    return null;
  }
}

// ============================================================================
// Atomicals Detection
// ============================================================================

/**
 * Detect Atomicals protocol from witness data
 * Atomicals use a specific envelope format with "atom" marker
 */
function detectAtomicals(witness) {
  if (!witness || witness.length === 0) return null;

  for (const item of witness) {
    const itemLower = item.toLowerCase();

    // Look for "atom" marker (61746f6d in hex)
    if (itemLower.includes('61746f6d')) {
      // Basic detection - more detailed parsing would require full Atomicals spec
      const result = {
        type: 'nft',
      };

      // Check for realm ($) or container (#) markers in the content
      const ascii = hexToAscii(itemLower);
      if (ascii.includes('"realm"') || ascii.includes('$')) {
        result.type = 'realm';
        // Try to extract realm name
        const realmMatch = ascii.match(/"realm"\s*:\s*"([^"]+)"/);
        if (realmMatch) {
          result.realmName = realmMatch[1];
        }
      } else if (ascii.includes('"container"') || ascii.includes('#')) {
        result.type = 'container';
        const containerMatch = ascii.match(/"container"\s*:\s*"([^"]+)"/);
        if (containerMatch) {
          result.containerName = containerMatch[1];
        }
      } else if (ascii.includes('"ft"') || ascii.includes('"fungible"')) {
        result.type = 'ft';
      }

      return result;
    }
  }

  return null;
}

// ============================================================================
// Protocol Detection
// ============================================================================

/**
 * Detect protocols in OP_RETURN data
 */
function detectOpReturnProtocol(data) {
  const dataLower = data.toLowerCase();

  // Runes detection - two formats:
  // 1. New format (post-launch): OP_13 (0x5d) marker
  // 2. Old format: "R" (0x52) - note: push opcode already stripped by parseOpReturnData
  const isNewRunesFormat = dataLower.startsWith('5d');
  const isOldRunesFormat = dataLower.startsWith('52');

  if (isNewRunesFormat || isOldRunesFormat) {
    // Extract payload after marker (skip the 1-byte marker)
    let payloadHex = data.slice(2);

    // If there's a push opcode for the payload, skip it
    if (payloadHex.length >= 2) {
      const firstByte = parseInt(payloadHex.slice(0, 2), 16);
      if (firstByte <= 0x4b && firstByte > 0) {
        payloadHex = payloadHex.slice(2);
      } else if (firstByte === 0x4c) {
        payloadHex = payloadHex.slice(4);
      } else if (firstByte === 0x4d) {
        payloadHex = payloadHex.slice(6);
      }
    }

    // Parse the Runes payload
    const runesPayload = hexToBytes(payloadHex);
    const runesDetails = parseRunesPayload(runesPayload);

    return {
      type: 'runes',
      data,
      details: runesDetails || undefined,
    };
  }

  // Stamps: STAMP: prefix (5354414d503a in hex)
  const stampsMarker = '5354414d503a';
  if (dataLower.includes(stampsMarker)) {
    return { type: 'stamps', data };
  }

  // Counterparty: CNTRPRTY prefix (434e545250525459 in hex)
  const counterpartyMarker = '434e545250525459';
  if (dataLower.includes(counterpartyMarker)) {
    return { type: 'counterparty', data };
  }

  return null;
}

/**
 * Detect Ordinals inscription in witness data
 * Ordinals use taproot (P2TR) with envelope format:
 * OP_FALSE OP_IF ... "ord" ... content-type ... OP_0 ... data ... OP_ENDIF
 */
function detectOrdinalsInWitness(witness) {
  if (!witness || witness.length === 0) return null;

  // Check for "ord" marker in any witness item
  const ordMarker = '6f7264'; // "ord" in hex
  let hasOrdMarker = false;

  for (const item of witness) {
    if (item.toLowerCase().includes(ordMarker)) {
      hasOrdMarker = true;
      break;
    }
  }

  if (!hasOrdMarker) return null;

  // Use the full envelope parser
  const inscription = parseOrdinalsEnvelope(witness);

  if (inscription) {
    return {
      type: 'ordinals',
      contentType: inscription.contentType,
      contentLength: inscription.contentLength,
      inscription,
    };
  }

  // Fallback: basic detection without full parsing
  for (const item of witness) {
    const itemLower = item.toLowerCase();
    if (itemLower.includes(ordMarker)) {
      // Try to extract content-type manually
      let contentType;
      let contentLength;

      const ordPos = itemLower.indexOf(ordMarker);
      if (ordPos !== -1) {
        const afterOrd = itemLower.slice(ordPos + 6);

        // Format: 01 (OP_1) + push_len + content-type + 00 (OP_0) + push_len + data + 68 (OP_ENDIF)
        if (afterOrd.startsWith('01')) {
          const ctLen = parseInt(afterOrd.slice(2, 4), 16);
          if (ctLen > 0 && ctLen < 100) {
            const ctHex = afterOrd.slice(4, 4 + ctLen * 2);
            contentType = hexToAscii(ctHex).replace(/\./g, '');
          }
        }

        const dataStart = afterOrd.indexOf('00');
        if (dataStart !== -1) {
          const remaining = afterOrd.slice(dataStart);
          contentLength = Math.floor(remaining.length / 2) - 2;
        }
      }

      return { type: 'ordinals', contentType, contentLength };
    }
  }

  return null;
}

/**
 * Detect BRC-20 token operation in inscription data
 */
function detectBrc20(witnessOrOpReturn) {
  // BRC-20 inscriptions contain JSON: {"p":"brc-20","op":"...","tick":"...","amt":"..."}
  const ascii = hexToAscii(witnessOrOpReturn);

  // Look for BRC-20 JSON pattern
  if (ascii.includes('"p":"brc-20"') || ascii.includes('"p": "brc-20"')) {
    try {
      // Try to find and parse the JSON
      const jsonMatch = ascii.match(/\{[^{}]*"p"\s*:\s*"brc-20"[^{}]*\}/);
      if (jsonMatch) {
        const brc20Details = parseBRC20(jsonMatch[0]);
        if (brc20Details) {
          return {
            type: 'brc20',
            operation: brc20Details.op,
            tick: brc20Details.tick,
            amount: brc20Details.amt,
            details: brc20Details,
          };
        }
        // Fallback if parsing failed but pattern matched
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          type: 'brc20',
          operation: parsed.op || 'unknown',
          tick: parsed.tick,
          amount: parsed.amt
        };
      }
    } catch {
      // JSON parse failed, but we still detected BRC-20 pattern
      return { type: 'brc20', operation: 'unknown' };
    }
  }

  return null;
}

/**
 * Detect all protocols in a transaction
 */
function detectProtocols(inputs, outputs) {
  const protocols = [];
  const seenTypes = new Set();

  // Check OP_RETURN outputs
  for (const output of outputs) {
    if (output.opReturnData) {
      // Check for known OP_RETURN protocols
      const protocol = detectOpReturnProtocol(output.opReturnData.hex);
      if (protocol && !seenTypes.has(protocol.type)) {
        protocols.push(protocol);
        seenTypes.add(protocol.type);
      }
    }
  }

  // Check witness data for Ordinals/BRC-20/CAT-21/Atomicals
  for (const input of inputs) {
    if (input.witness && input.witness.length > 0) {
      // Check for Ordinals
      const ordinals = detectOrdinalsInWitness(input.witness);
      if (ordinals && !seenTypes.has('ordinals')) {
        protocols.push(ordinals);
        seenTypes.add('ordinals');

        // If we have a full inscription, check for BRC-20 and CAT-21
        if (ordinals.type === 'ordinals' && ordinals.inscription) {
          // Check for BRC-20
          const brc20Details = detectBrc20FromInscription(ordinals.inscription);
          if (brc20Details && !seenTypes.has('brc20')) {
            protocols.push({
              type: 'brc20',
              operation: brc20Details.op,
              tick: brc20Details.tick,
              amount: brc20Details.amt,
              details: brc20Details,
            });
            seenTypes.add('brc20');
          }

          // Check for CAT-21
          const cat21 = detectCAT21(ordinals.inscription);
          if (cat21 && !seenTypes.has('cat21')) {
            protocols.push({
              type: 'cat21',
              details: cat21,
            });
            seenTypes.add('cat21');
          }
        } else {
          // Fallback: check witness items directly for BRC-20
          for (const item of input.witness) {
            const brc20 = detectBrc20(item);
            if (brc20 && !seenTypes.has('brc20')) {
              protocols.push(brc20);
              seenTypes.add('brc20');
              break;
            }
          }
        }
      }

      // Check for Atomicals (uses different envelope)
      if (!seenTypes.has('atomicals')) {
        const atomicals = detectAtomicals(input.witness);
        if (atomicals) {
          protocols.push({
            type: 'atomicals',
            details: atomicals,
          });
          seenTypes.add('atomicals');
        }
      }
    }
  }

  return protocols;
}

// ============================================================================
// Non-Standard Transaction Detection
// ============================================================================

/**
 * Get dust limit for a given script type
 */
function getDustLimit(scriptType) {
  switch (scriptType) {
    case 'p2pkh': return LIMITS.DUST_P2PKH;
    case 'p2wpkh': return LIMITS.DUST_P2WPKH;
    case 'p2tr': return LIMITS.DUST_P2TR;
    case 'p2sh': return LIMITS.DUST_P2SH;
    case 'p2wsh': return LIMITS.DUST_P2WSH;
    case 'op_return': return 0; // OP_RETURN must be 0
    default: return LIMITS.DUST_P2PKH; // Conservative default
  }
}

/**
 * Detect non-standard transaction issues
 * Based on Bitcoin Core policy.h and standardness rules
 */
function detectNonStandard(tx) {
  const checks = [];

  // -----------------------------------------------------------------------
  // Category 1: Transaction Size/Weight
  // -----------------------------------------------------------------------

  if (tx.size < LIMITS.MIN_TX_SIZE) {
    checks.push({
      category: 'size',
      code: 'tx-size-small',
      severity: 'error',
      message: 'Transaction too small',
      details: 'Minimum non-witness size is 82 bytes (smallest valid P2WPKH)',
      limit: `\u2265${LIMITS.MIN_TX_SIZE} bytes`,
      actual: `${tx.size} bytes`,
    });
  }

  if (tx.weight > LIMITS.MAX_STANDARD_TX_WEIGHT) {
    checks.push({
      category: 'size',
      code: 'tx-size',
      severity: 'error',
      message: 'Transaction too large',
      details: 'Exceeds MAX_STANDARD_TX_WEIGHT (100 kvB)',
      limit: `\u2264${LIMITS.MAX_STANDARD_TX_WEIGHT} WU`,
      actual: `${tx.weight} WU`,
    });
  }

  // -----------------------------------------------------------------------
  // Category 2: Transaction Version
  // -----------------------------------------------------------------------

  if (tx.version < 1 || tx.version > LIMITS.MAX_STANDARD_VERSION) {
    checks.push({
      category: 'version',
      code: 'version',
      severity: 'error',
      message: `Non-standard version: ${tx.version}`,
      details: 'Only version 1 and 2 are standard. Version 3 reserved for package relay.',
      limit: '1 or 2',
      actual: `${tx.version}`,
    });
  }

  // -----------------------------------------------------------------------
  // Category 9: Input Limits
  // -----------------------------------------------------------------------

  // Check for coinbase transaction (non-relayable)
  const isCoinbase = tx.inputs.length === 1 &&
    tx.inputs[0].txid === '0000000000000000000000000000000000000000000000000000000000000000' &&
    tx.inputs[0].vout === 0xffffffff;

  if (isCoinbase) {
    checks.push({
      category: 'input',
      code: 'coinbase',
      severity: 'error',
      message: 'Coinbase transaction',
      details: 'Coinbase transactions cannot be relayed - they are only valid in blocks',
    });
  }

  for (let i = 0; i < tx.inputs.length; i++) {
    const input = tx.inputs[i];

    // ScriptSig size limit
    const scriptSigSize = input.scriptSig.length / 2;
    if (scriptSigSize > LIMITS.MAX_SCRIPTSIG_SIZE) {
      checks.push({
        category: 'input',
        code: 'bad-txns-nonstandard-inputs',
        severity: 'error',
        message: `Input #${i}: scriptSig too large`,
        details: 'ScriptSig exceeds maximum standard size (~15-of-15 multisig limit)',
        limit: `\u2264${LIMITS.MAX_SCRIPTSIG_SIZE} bytes`,
        actual: `${scriptSigSize} bytes`,
      });
    }

    // Check for non-push-only scriptSig (basic check)
    // Push-only means no opcodes other than data pushes
    if (input.scriptSig && input.scriptSig.length > 0) {
      const firstByte = parseInt(input.scriptSig.slice(0, 2), 16);
      // Opcodes 0x01-0x4e are pushes, 0x00 is OP_0 (push empty), >0x60 are non-push
      if (firstByte > 0x60 && firstByte !== 0x00) {
        checks.push({
          category: 'input',
          code: 'bad-txns-nonstandard-inputs',
          severity: 'warning',
          message: `Input #${i}: scriptSig may contain non-push opcodes`,
          details: 'ScriptSig must be push-only (no executable opcodes)',
        });
      }
    }
  }

  // -----------------------------------------------------------------------
  // Category 8: Witness Limits
  // -----------------------------------------------------------------------

  for (let i = 0; i < tx.inputs.length; i++) {
    const input = tx.inputs[i];
    if (input.witness && input.witness.length > 0) {
      // Stack item count
      if (input.witness.length > LIMITS.MAX_STANDARD_P2WSH_STACK_ITEMS) {
        checks.push({
          category: 'witness',
          code: 'bad-witness-nonstandard',
          severity: 'error',
          message: `Input #${i}: too many witness stack items`,
          limit: `\u2264${LIMITS.MAX_STANDARD_P2WSH_STACK_ITEMS}`,
          actual: `${input.witness.length}`,
        });
      }

      // Check each witness item size (80 bytes max for P2WSH)
      for (let j = 0; j < input.witness.length; j++) {
        const itemSize = input.witness[j].length / 2;
        if (itemSize > 80 && j < input.witness.length - 1) {
          // Last item can be the script which is allowed to be larger
          checks.push({
            category: 'witness',
            code: 'bad-witness-nonstandard',
            severity: 'warning',
            message: `Input #${i}: witness item #${j} exceeds 80 bytes`,
            details: 'P2WSH stack items (except script) limited to 80 bytes',
            limit: '\u226480 bytes',
            actual: `${itemSize} bytes`,
          });
        }
      }

      // Check last witness item (script) size for P2WSH
      const lastItem = input.witness[input.witness.length - 1];
      const scriptSize = lastItem.length / 2;
      if (scriptSize > LIMITS.MAX_STANDARD_P2WSH_SCRIPT_SIZE) {
        checks.push({
          category: 'witness',
          code: 'bad-witness-nonstandard',
          severity: 'error',
          message: `Input #${i}: P2WSH script too large`,
          limit: `\u2264${LIMITS.MAX_STANDARD_P2WSH_SCRIPT_SIZE} bytes`,
          actual: `${scriptSize} bytes`,
        });
      }
    }
  }

  // -----------------------------------------------------------------------
  // Category 10: Output Limits
  // -----------------------------------------------------------------------

  // Multiple OP_RETURN outputs
  if (tx.opReturnCount > LIMITS.MAX_OP_RETURN_COUNT) {
    checks.push({
      category: 'output',
      code: 'multi-op-return',
      severity: 'error',
      message: 'Multiple OP_RETURN outputs',
      details: 'Only one OP_RETURN data carrier output is standard',
      limit: `\u2264${LIMITS.MAX_OP_RETURN_COUNT}`,
      actual: `${tx.opReturnCount}`,
    });
  }

  for (let i = 0; i < tx.outputs.length; i++) {
    const output = tx.outputs[i];

    // OP_RETURN size limit
    if (output.scriptType === 'op_return') {
      const opReturnSize = output.scriptPubKey.length / 2;
      if (opReturnSize > LIMITS.MAX_OP_RETURN_RELAY) {
        checks.push({
          category: 'output',
          code: 'scriptpubkey',
          severity: 'error',
          message: `Output #${i}: OP_RETURN too large`,
          details: 'OP_RETURN data exceeds relay limit',
          limit: `\u2264${LIMITS.MAX_OP_RETURN_RELAY} bytes`,
          actual: `${opReturnSize} bytes`,
        });
      }
      // OP_RETURN must have 0 value
      if (output.value > 0) {
        checks.push({
          category: 'output',
          code: 'dust',
          severity: 'error',
          message: `Output #${i}: OP_RETURN has non-zero value`,
          details: 'OP_RETURN outputs must be unspendable (0 sats)',
          limit: '0 sats',
          actual: `${output.value} sats`,
        });
      }
      continue;
    }

    // Unknown/non-standard output types
    if (output.scriptType === 'unknown' || output.scriptType === 'nonstandard') {
      checks.push({
        category: 'output',
        code: 'scriptpubkey',
        severity: 'error',
        message: `Output #${i}: non-standard script type`,
        details: 'Output script does not match any standard template',
      });
    }

    // Bare multisig check
    if (output.scriptType === 'multisig') {
      checks.push({
        category: 'output',
        code: 'bare-multisig',
        severity: 'warning',
        message: `Output #${i}: bare multisig output`,
        details: 'Bare multisig is non-standard by default (use P2SH-wrapped instead)',
      });
    }

    // Dust check (skip OP_RETURN)
    const dustLimit = getDustLimit(output.scriptType);
    if (output.value > 0 && output.value < dustLimit) {
      checks.push({
        category: 'output',
        code: 'dust',
        severity: 'error',
        message: `Output #${i}: dust output`,
        details: `Value below economic spend threshold for ${output.scriptType.toUpperCase()}`,
        limit: `\u2265${dustLimit} sats`,
        actual: `${output.value} sats`,
      });
    }
  }

  // Build summary
  const isStandard = checks.length === 0;
  const errorCount = checks.filter(c => c.severity === 'error').length;
  const warningCount = checks.filter(c => c.severity === 'warning').length;

  let summary;
  if (isStandard) {
    summary = 'Transaction passes all standard policy checks';
  } else if (errorCount > 0 && warningCount > 0) {
    summary = `${errorCount} policy violation${errorCount > 1 ? 's' : ''}, ${warningCount} warning${warningCount > 1 ? 's' : ''}`;
  } else if (errorCount > 0) {
    summary = `${errorCount} policy violation${errorCount > 1 ? 's' : ''} - will be rejected by default nodes`;
  } else {
    summary = `${warningCount} warning${warningCount > 1 ? 's' : ''} - may be rejected by some nodes`;
  }

  return { isStandard, checks, summary };
}

// ============================================================================
// Main Decoder
// ============================================================================

async function decodeTransaction(hexInput) {
  // Sanitize input to ensure accurate size calculation
  const hex = hexInput.replace(/\s+/g, '');
  const reader = new ByteReader(hex);
  const warnings = [];

  // Version (4 bytes)
  const version = reader.readUInt32LE();
  if (version !== 1 && version !== 2) {
    warnings.push(`Unusual version: ${version}`);
  }

  // Check for SegWit marker
  let isSegwit = false;
  const marker = reader.peek(1); // Peek 1 byte (2 hex chars)
  if (marker === '00') {
    reader.readUInt8(); // marker
    const flag = reader.readUInt8();
    if (flag !== 1) {
      throw new Error(`Invalid SegWit flag: ${flag}`);
    }
    isSegwit = true;
  }

  // Input count
  const inputCount = reader.readVarInt();
  if (inputCount === 0 && !isSegwit) {
    throw new Error('Transaction has no inputs');
  }

  // Inputs
  const inputs = [];
  let isRbfSignaled = false;

  for (let i = 0; i < inputCount; i++) {
    const txid = reader.readHash256();
    const vout = reader.readUInt32LE();
    const scriptSigLen = reader.readVarInt();
    const scriptSig = reader.readBytes(scriptSigLen);
    const sequence = reader.readUInt32LE();

    const isRbfEnabled = sequence < 0xfffffffe;
    if (isRbfEnabled) isRbfSignaled = true;

    inputs.push({
      txid,
      vout,
      scriptSig,
      scriptSigAsm: scriptSig ? disassembleScript(scriptSig) : '(empty)',
      sequence,
      isRbfEnabled,
    });
  }

  // Output count
  const outputCount = reader.readVarInt();

  // Outputs
  const outputs = [];
  let totalOutputSats = 0;
  let hasOpReturn = false;
  let opReturnCount = 0;

  for (let i = 0; i < outputCount; i++) {
    const value = Number(reader.readUInt64LE());
    totalOutputSats += value;

    const scriptPubKeyLen = reader.readVarInt();
    const scriptPubKey = reader.readBytes(scriptPubKeyLen);

    const { type: scriptType, data } = identifyScriptType(scriptPubKey);

    const output = {
      value,
      valueBtc: satsToBtc(value),
      scriptPubKey,
      scriptType,
    };

    // Get address for standard types
    if (data && scriptType !== 'op_return') {
      output.address = await scriptToAddress(scriptType, data);
    }

    // Handle OP_RETURN
    if (scriptType === 'op_return') {
      hasOpReturn = true;
      opReturnCount++;
      if (data) {
        output.opReturnData = parseOpReturnData(data);
      }
    }

    outputs.push(output);
  }

  // Witness data (if SegWit)
  if (isSegwit) {
    for (let i = 0; i < inputCount; i++) {
      const witnessCount = reader.readVarInt();
      const witness = [];
      for (let j = 0; j < witnessCount; j++) {
        const itemLen = reader.readVarInt();
        witness.push(reader.readBytes(itemLen));
      }
      inputs[i].witness = witness;
    }
  }

  // Locktime (4 bytes)
  const locktime = reader.readUInt32LE();
  let locktimeType = 'none';
  let locktimeValue = 'None (immediately spendable)';

  if (locktime > 0) {
    if (locktime < 500_000_000) {
      locktimeType = 'block';
      locktimeValue = `Block ${locktime.toLocaleString()}`;
    } else {
      locktimeType = 'timestamp';
      const date = new Date(locktime * 1000);
      locktimeValue = date.toISOString();
    }
  }

  // Calculate sizes
  const size = hex.length / 2;
  let weight;
  let vsize;

  if (isSegwit) {
    // For SegWit, we need to calculate non-witness and witness sizes
    // This is an approximation - for exact, we'd need to track positions
    const baseSize = size - (isSegwit ? 2 : 0); // Subtract marker+flag
    // Rough witness discount calculation
    weight = baseSize * 3 + size;
    vsize = Math.ceil(weight / 4);
  } else {
    weight = size * 4;
    vsize = size;
  }

  // Calculate TXID
  const txid = await calculateTxid(hex, isSegwit);

  // Sanity checks
  if (reader.remaining > 0) {
    warnings.push(`${reader.remaining} bytes remaining after parsing`);
  }

  if (totalOutputSats > 21_000_000 * 100_000_000) {
    warnings.push('Total output exceeds 21M BTC!');
  }

  // Detect protocols (Ordinals, BRC-20, Runes, etc.)
  const detectedProtocols = detectProtocols(inputs, outputs);

  // Detect non-standard policy issues
  const nonStandardReport = detectNonStandard({
    version,
    size,
    weight,
    inputs,
    outputs,
    opReturnCount,
  });

  return {
    txid,
    version,
    isSegwit,
    inputs,
    outputs,
    locktime,
    locktimeType,
    locktimeValue,
    size,
    vsize,
    weight,
    totalOutputSats,
    totalOutputBtc: satsToBtc(totalOutputSats),
    hasOpReturn,
    opReturnCount,
    isRbfSignaled,
    detectedProtocols,
    nonStandardReport,
    warnings,
  };
}

async function calculateTxid(hex, isSegwit) {
  let txForHash = hex;

  if (isSegwit) {
    // For SegWit, TXID is calculated without witness data
    // This is a simplified approach - strip marker, flag, and witness
    const reader = new ByteReader(hex);

    // Version
    const version = reader.readBytes(4);
    reader.readBytes(2); // Skip marker+flag

    // Count inputs
    const inputCount = reader.readVarInt();
    const inputCountHex = inputCount < 0xfd ?
      inputCount.toString(16).padStart(2, '0') :
      'fd' + inputCount.toString(16).padStart(4, '0');

    let inputsHex = '';
    for (let i = 0; i < inputCount; i++) {
      inputsHex += reader.readBytes(32); // txid (unreversed in raw)
      inputsHex += reader.readBytes(4);  // vout
      const scriptLen = reader.readVarInt();
      const scriptLenHex = scriptLen < 0xfd ?
        scriptLen.toString(16).padStart(2, '0') :
        'fd' + scriptLen.toString(16).padStart(4, '0');
      inputsHex += scriptLenHex;
      inputsHex += reader.readBytes(scriptLen); // scriptSig
      inputsHex += reader.readBytes(4); // sequence
    }

    // Count outputs
    const outputCount = reader.readVarInt();
    const outputCountHex = outputCount < 0xfd ?
      outputCount.toString(16).padStart(2, '0') :
      'fd' + outputCount.toString(16).padStart(4, '0');

    let outputsHex = '';
    for (let i = 0; i < outputCount; i++) {
      outputsHex += reader.readBytes(8); // value
      const scriptLen = reader.readVarInt();
      const scriptLenHex = scriptLen < 0xfd ?
        scriptLen.toString(16).padStart(2, '0') :
        'fd' + scriptLen.toString(16).padStart(4, '0');
      outputsHex += scriptLenHex;
      outputsHex += reader.readBytes(scriptLen); // scriptPubKey
    }

    // Skip witness data, get locktime
    for (let i = 0; i < inputCount; i++) {
      const witnessCount = reader.readVarInt();
      for (let j = 0; j < witnessCount; j++) {
        const itemLen = reader.readVarInt();
        reader.readBytes(itemLen);
      }
    }

    const locktime = reader.readBytes(4);

    txForHash = version + inputCountHex + inputsHex + outputCountHex + outputsHex + locktime;
  }

  // Convert to bytes
  const bytes = new Uint8Array(txForHash.length / 2);
  for (let i = 0; i < txForHash.length; i += 2) {
    bytes[i / 2] = parseInt(txForHash.slice(i, i + 2), 16);
  }

  // Double SHA256
  const hash = await doubleSha256(bytes);

  // Reverse for display
  return Array.from(hash).reverse().map(b => b.toString(16).padStart(2, '0')).join('');
}

// ============================================================================
// Quick validation (synchronous, for form validation)
// ============================================================================

function isValidTransactionHex(hex) {
  if (!hex || hex.length === 0) {
    return { valid: false, error: 'Empty input' };
  }

  const cleaned = hex.trim().toLowerCase();

  if (!/^[0-9a-f]+$/.test(cleaned)) {
    return { valid: false, error: 'Invalid hex characters' };
  }

  if (cleaned.length % 2 !== 0) {
    return { valid: false, error: 'Odd number of hex characters' };
  }

  if (cleaned.length < 20) {
    return { valid: false, error: 'Too short to be a valid transaction' };
  }

  // Check version (first 4 bytes, little-endian)
  const version = parseInt(cleaned.slice(6, 8) + cleaned.slice(4, 6) + cleaned.slice(2, 4) + cleaned.slice(0, 2), 16);
  if (version !== 1 && version !== 2) {
    // Could still be valid but unusual
  }

  return { valid: true };
}

// ============================================================================
// PSBT (BIP-174) Decoder
// ============================================================================

// PSBT key types
const PSBT_GLOBAL_UNSIGNED_TX = 0x00;
const PSBT_GLOBAL_XPUB = 0x01;
const PSBT_GLOBAL_VERSION = 0xfb;

const PSBT_IN_NON_WITNESS_UTXO = 0x00;
const PSBT_IN_WITNESS_UTXO = 0x01;
const PSBT_IN_PARTIAL_SIG = 0x02;
const PSBT_IN_SIGHASH_TYPE = 0x03;
const PSBT_IN_REDEEM_SCRIPT = 0x04;
const PSBT_IN_WITNESS_SCRIPT = 0x05;
const PSBT_IN_BIP32_DERIVATION = 0x06;
const PSBT_IN_FINAL_SCRIPTSIG = 0x07;
const PSBT_IN_FINAL_SCRIPTWITNESS = 0x08;

const PSBT_OUT_REDEEM_SCRIPT = 0x00;
const PSBT_OUT_WITNESS_SCRIPT = 0x01;
const PSBT_OUT_BIP32_DERIVATION = 0x02;

function parseBip32Path(data) {
  // First 4 bytes are master fingerprint, rest are path components (4 bytes each)
  const parts = ['m'];
  for (let i = 8; i < data.length; i += 8) {
    const index = parseInt(
      data.slice(i + 6, i + 8) + data.slice(i + 4, i + 6) +
      data.slice(i + 2, i + 4) + data.slice(i, i + 2),
      16
    );
    if (index >= 0x80000000) {
      parts.push((index - 0x80000000).toString() + "'");
    } else {
      parts.push(index.toString());
    }
  }
  return parts.join('/');
}

function isPSBT(data) {
  const cleaned = data.trim().toLowerCase();
  // Check for hex PSBT magic
  if (cleaned.startsWith('70736274ff')) {
    return true;
  }
  // Check for base64 PSBT (starts with "cHNidP8" which is base64 for "psbt\xff")
  if (data.trim().startsWith('cHNidP8')) {
    return true;
  }
  return false;
}

function base64ToHex(base64) {
  const binary = atob(base64);
  let hex = '';
  for (let i = 0; i < binary.length; i++) {
    hex += binary.charCodeAt(i).toString(16).padStart(2, '0');
  }
  return hex;
}

async function decodePSBT(dataInput) {
  // Sanitize input - remove all whitespace
  const data = dataInput.replace(/\s+/g, '');
  let hex = data.toLowerCase();

  // Convert base64 to hex if needed
  if (data.startsWith('cHNidP8')) {
    hex = base64ToHex(data);
  }

  const reader = new ByteReader(hex);
  const warnings = [];

  // Check magic bytes (0x70736274ff = "psbt" + separator)
  const magic = reader.readBytes(5);
  if (magic !== '70736274ff') {
    throw new Error('Invalid PSBT magic bytes');
  }

  // Parse global section
  let unsignedTxHex;
  let psbtVersion = 0;
  const globalXpubs = [];
  const unknownGlobals = [];

  while (true) {
    const keyLen = reader.readVarInt();
    if (keyLen === 0) break; // End of global section

    const key = reader.readBytes(keyLen);
    const keyType = parseInt(key.slice(0, 2), 16);
    const keyData = key.slice(2);

    const valueLen = reader.readVarInt();
    const value = reader.readBytes(valueLen);

    switch (keyType) {
      case PSBT_GLOBAL_UNSIGNED_TX:
        unsignedTxHex = value;
        break;
      case PSBT_GLOBAL_XPUB:
        globalXpubs.push({
          xpub: keyData,
          masterFingerprint: value.slice(0, 8),
          path: parseBip32Path(value),
        });
        break;
      case PSBT_GLOBAL_VERSION:
        psbtVersion = parseInt(value, 16);
        break;
      default:
        unknownGlobals.push({ key, value });
    }
  }

  if (!unsignedTxHex) {
    throw new Error('PSBT missing unsigned transaction');
  }

  // Decode the unsigned transaction
  const unsignedTx = await decodeTransaction(unsignedTxHex);

  // Parse input sections
  const psbtInputs = [];
  let totalInputValue = 0;
  let inputsWithValue = 0;

  for (let i = 0; i < unsignedTx.inputs.length; i++) {
    const input = {
      index: i,
      partialSigs: [],
      bip32Derivation: [],
      hasAllSignatures: false,
    };

    while (true) {
      const keyLen = reader.readVarInt();
      if (keyLen === 0) break;

      const key = reader.readBytes(keyLen);
      const keyType = parseInt(key.slice(0, 2), 16);
      const keyData = key.slice(2);

      const valueLen = reader.readVarInt();
      const value = reader.readBytes(valueLen);

      switch (keyType) {
        case PSBT_IN_NON_WITNESS_UTXO:
          input.nonWitnessUtxo = value;
          break;

        case PSBT_IN_WITNESS_UTXO: {
          // Parse witness UTXO: value (8 bytes) + scriptPubKey
          const utxoReader = new ByteReader(value);
          const utxoValue = Number(utxoReader.readUInt64LE());
          const scriptLen = utxoReader.readVarInt();
          const scriptPubKey = utxoReader.readBytes(scriptLen);
          const { type: scriptType, data: scriptData } = identifyScriptType(scriptPubKey);

          input.witnessUtxo = {
            value: utxoValue,
            valueBtc: satsToBtc(utxoValue),
            scriptPubKey,
            scriptType,
            address: scriptData ? await scriptToAddress(scriptType, scriptData) : undefined,
          };

          totalInputValue += utxoValue;
          inputsWithValue++;
          break;
        }

        case PSBT_IN_PARTIAL_SIG:
          input.partialSigs.push({
            pubkey: keyData,
            signature: value,
          });
          break;

        case PSBT_IN_SIGHASH_TYPE:
          input.sighashType = parseInt(value, 16);
          break;

        case PSBT_IN_REDEEM_SCRIPT:
          input.redeemScript = value;
          break;

        case PSBT_IN_WITNESS_SCRIPT:
          input.witnessScript = value;
          break;

        case PSBT_IN_BIP32_DERIVATION:
          input.bip32Derivation.push({
            pubkey: keyData,
            masterFingerprint: value.slice(0, 8),
            path: parseBip32Path(value),
          });
          break;

        case PSBT_IN_FINAL_SCRIPTSIG:
          input.finalScriptSig = value;
          input.hasAllSignatures = true;
          break;

        case PSBT_IN_FINAL_SCRIPTWITNESS: {
          // Parse witness stack
          const witnessReader = new ByteReader(value);
          const witnessCount = witnessReader.readVarInt();
          input.finalScriptWitness = [];
          for (let w = 0; w < witnessCount; w++) {
            const itemLen = witnessReader.readVarInt();
            input.finalScriptWitness.push(witnessReader.readBytes(itemLen));
          }
          input.hasAllSignatures = true;
          break;
        }
      }
    }

    // Check if has signatures (either finalized or partial)
    if (input.partialSigs.length > 0) {
      input.hasAllSignatures = true; // Simplified - real check would need to know required sigs
    }

    psbtInputs.push(input);
  }

  // Parse output sections
  const psbtOutputs = [];

  for (let i = 0; i < unsignedTx.outputs.length; i++) {
    const output = {
      index: i,
      bip32Derivation: [],
    };

    while (true) {
      const keyLen = reader.readVarInt();
      if (keyLen === 0) break;

      const key = reader.readBytes(keyLen);
      const keyType = parseInt(key.slice(0, 2), 16);
      const keyData = key.slice(2);

      const valueLen = reader.readVarInt();
      const value = reader.readBytes(valueLen);

      switch (keyType) {
        case PSBT_OUT_REDEEM_SCRIPT:
          output.redeemScript = value;
          break;
        case PSBT_OUT_WITNESS_SCRIPT:
          output.witnessScript = value;
          break;
        case PSBT_OUT_BIP32_DERIVATION:
          output.bip32Derivation.push({
            pubkey: keyData,
            masterFingerprint: value.slice(0, 8),
            path: parseBip32Path(value),
          });
          break;
      }
    }

    psbtOutputs.push(output);
  }

  // Calculate totals and fee
  const totalOutputValue = unsignedTx.totalOutputSats;
  let fee;
  let feeBtc;
  let feeRate;

  if (inputsWithValue === unsignedTx.inputs.length && totalInputValue > 0) {
    fee = totalInputValue - totalOutputValue;
    feeBtc = satsToBtc(fee);
    feeRate = Math.round(fee / unsignedTx.vsize * 100) / 100;

    if (fee < 0) {
      warnings.push('Negative fee! Outputs exceed inputs.');
    } else if (feeRate > 1000) {
      warnings.push(`Very high fee rate: ${feeRate} sat/vB`);
    } else if (feeRate < 1) {
      warnings.push(`Very low fee rate: ${feeRate} sat/vB - may not confirm`);
    } else if (feeRate < 5) {
      warnings.push(`Low fee rate: ${feeRate} sat/vB - may take a long time to confirm`);
    }
  }

  // Signing progress
  const signedInputs = psbtInputs.filter(i => i.hasAllSignatures).length;
  const signingProgress = `${signedInputs}/${unsignedTx.inputs.length} inputs signed`;
  const isFullySigned = signedInputs === unsignedTx.inputs.length;

  return {
    isPsbt: true,
    version: psbtVersion,
    unsignedTx,
    inputs: psbtInputs,
    outputs: psbtOutputs,
    globalXpubs,
    unknownGlobals,
    totalInputValue,
    totalInputBtc: satsToBtc(totalInputValue),
    totalOutputValue,
    totalOutputBtc: satsToBtc(totalOutputValue),
    fee,
    feeBtc,
    feeRate,
    isFullySigned,
    signingProgress,
    warnings,
  };
}

// ============================================================================
// Unified decode function - handles both raw TX and PSBT
// ============================================================================

/**
 * Sanitize input by removing all whitespace (spaces, tabs, newlines, etc.)
 * This allows users to paste hex with formatting
 */
function sanitizeHexInput(input) {
  return input.replace(/\s+/g, '');
}

async function decodeAny(input) {
  // Strip ALL whitespace to handle formatted/indented input
  const cleaned = sanitizeHexInput(input);

  if (isPSBT(cleaned)) {
    return { type: 'psbt', data: await decodePSBT(cleaned) };
  }

  return { type: 'transaction', data: await decodeTransaction(cleaned) };
}

// Helper to detect input type without full decode

function detectInputType(input) {
  // Strip ALL whitespace (spaces, newlines, tabs, etc.)
  const cleaned = sanitizeHexInput(input);

  if (!cleaned) return 'invalid';

  // Check for PSBT (base64 or hex)
  if (isPSBT(cleaned)) return 'psbt';

  // Check for valid hex
  if (/^[0-9a-fA-F]+$/.test(cleaned) && cleaned.length >= 20) {
    return 'transaction';
  }

  return 'invalid';
}

// ============================================================================
// PSBT Finalization & Transaction Extraction
// ============================================================================

/**
 * Check if a PSBT can be finalized (all inputs have final scripts)
 */
function canFinalizePSBT(psbt) {
  for (let i = 0; i < psbt.inputs.length; i++) {
    const input = psbt.inputs[i];

    // Check if input already has final scripts
    if (input.finalScriptSig || input.finalScriptWitness) {
      continue; // Already finalized
    }

    // Check if we have partial signatures
    if (input.partialSigs.length === 0) {
      return {
        canFinalize: false,
        reason: `Input #${i} has no signatures`
      };
    }

    // For now, we only support simple single-sig finalization
    // Multisig would need additional logic to determine if we have enough sigs
  }

  return { canFinalize: true };
}

/**
 * Helper to encode a varint
 */
function encodeVarInt(n) {
  if (n < 0xfd) {
    return n.toString(16).padStart(2, '0');
  } else if (n <= 0xffff) {
    return 'fd' +
      (n & 0xff).toString(16).padStart(2, '0') +
      ((n >> 8) & 0xff).toString(16).padStart(2, '0');
  } else if (n <= 0xffffffff) {
    return 'fe' +
      (n & 0xff).toString(16).padStart(2, '0') +
      ((n >> 8) & 0xff).toString(16).padStart(2, '0') +
      ((n >> 16) & 0xff).toString(16).padStart(2, '0') +
      ((n >> 24) & 0xff).toString(16).padStart(2, '0');
  }
  throw new Error('VarInt too large');
}

/**
 * Extract raw transaction hex from a finalized PSBT
 *
 * This takes a PSBT where inputs have finalScriptSig and/or finalScriptWitness
 * and constructs the complete raw transaction that can be broadcast.
 */
function extractTransactionFromPSBT(psbt) {
  // First check if we can finalize
  const { canFinalize, reason } = canFinalizePSBT(psbt);
  if (!canFinalize) {
    return { success: false, error: reason || 'PSBT cannot be finalized' };
  }

  // Check if any input needs witness (determines if we use SegWit serialization)
  let needsWitness = false;
  for (const input of psbt.inputs) {
    if (input.finalScriptWitness && input.finalScriptWitness.length > 0) {
      needsWitness = true;
      break;
    }
    // Also check if witnessUtxo suggests SegWit
    if (input.witnessUtxo?.scriptType === 'p2wpkh' ||
        input.witnessUtxo?.scriptType === 'p2wsh' ||
        input.witnessUtxo?.scriptType === 'p2tr') {
      needsWitness = true;
      break;
    }
  }

  try {
    let txHex = '';

    // Version (4 bytes LE)
    const version = psbt.unsignedTx.version;
    txHex += (version & 0xff).toString(16).padStart(2, '0');
    txHex += ((version >> 8) & 0xff).toString(16).padStart(2, '0');
    txHex += ((version >> 16) & 0xff).toString(16).padStart(2, '0');
    txHex += ((version >> 24) & 0xff).toString(16).padStart(2, '0');

    // SegWit marker + flag
    if (needsWitness) {
      txHex += '00'; // marker
      txHex += '01'; // flag
    }

    // Input count
    txHex += encodeVarInt(psbt.unsignedTx.inputs.length);

    // Inputs
    for (let i = 0; i < psbt.unsignedTx.inputs.length; i++) {
      const txInput = psbt.unsignedTx.inputs[i];
      const psbtInput = psbt.inputs[i];

      // Previous output txid (32 bytes, reversed for internal representation)
      // The txid in DecodedInput is already in display format, we need to reverse it
      const txidBytes = txInput.txid.match(/.{2}/g)?.reverse().join('') || '';
      txHex += txidBytes;

      // Previous output index (4 bytes LE)
      const vout = txInput.vout;
      txHex += (vout & 0xff).toString(16).padStart(2, '0');
      txHex += ((vout >> 8) & 0xff).toString(16).padStart(2, '0');
      txHex += ((vout >> 16) & 0xff).toString(16).padStart(2, '0');
      txHex += ((vout >> 24) & 0xff).toString(16).padStart(2, '0');

      // ScriptSig
      let scriptSig = '';
      if (psbtInput.finalScriptSig) {
        scriptSig = psbtInput.finalScriptSig;
      } else if (!needsWitness && psbtInput.partialSigs.length > 0) {
        // For legacy P2PKH, construct scriptSig from signature + pubkey
        // <sig> <pubkey>
        const sig = psbtInput.partialSigs[0].signature;
        const pubkey = psbtInput.partialSigs[0].pubkey;
        const sigLen = sig.length / 2;
        const pubkeyLen = pubkey.length / 2;
        scriptSig = sigLen.toString(16).padStart(2, '0') + sig +
                    pubkeyLen.toString(16).padStart(2, '0') + pubkey;
      }

      txHex += encodeVarInt(scriptSig.length / 2);
      txHex += scriptSig;

      // Sequence (4 bytes LE)
      const seq = txInput.sequence;
      txHex += (seq & 0xff).toString(16).padStart(2, '0');
      txHex += ((seq >> 8) & 0xff).toString(16).padStart(2, '0');
      txHex += ((seq >> 16) & 0xff).toString(16).padStart(2, '0');
      txHex += ((seq >> 24) & 0xff).toString(16).padStart(2, '0');
    }

    // Output count
    txHex += encodeVarInt(psbt.unsignedTx.outputs.length);

    // Outputs
    for (const output of psbt.unsignedTx.outputs) {
      // Value (8 bytes LE)
      let value = output.value;
      for (let j = 0; j < 8; j++) {
        txHex += (value & 0xff).toString(16).padStart(2, '0');
        value = Math.floor(value / 256);
      }

      // ScriptPubKey
      txHex += encodeVarInt(output.scriptPubKey.length / 2);
      txHex += output.scriptPubKey;
    }

    // Witness data (if SegWit)
    if (needsWitness) {
      for (let i = 0; i < psbt.inputs.length; i++) {
        const psbtInput = psbt.inputs[i];

        if (psbtInput.finalScriptWitness && psbtInput.finalScriptWitness.length > 0) {
          // Use final witness directly
          txHex += encodeVarInt(psbtInput.finalScriptWitness.length);
          for (const item of psbtInput.finalScriptWitness) {
            txHex += encodeVarInt(item.length / 2);
            txHex += item;
          }
        } else if (psbtInput.partialSigs.length > 0) {
          // Construct witness from partial sigs (P2WPKH: <sig> <pubkey>)
          const sig = psbtInput.partialSigs[0].signature;
          const pubkey = psbtInput.partialSigs[0].pubkey;
          txHex += '02'; // 2 witness items
          txHex += encodeVarInt(sig.length / 2);
          txHex += sig;
          txHex += encodeVarInt(pubkey.length / 2);
          txHex += pubkey;
        } else {
          // Empty witness
          txHex += '00';
        }
      }
    }

    // Locktime (4 bytes LE)
    const locktime = psbt.unsignedTx.locktime;
    txHex += (locktime & 0xff).toString(16).padStart(2, '0');
    txHex += ((locktime >> 8) & 0xff).toString(16).padStart(2, '0');
    txHex += ((locktime >> 16) & 0xff).toString(16).padStart(2, '0');
    txHex += ((locktime >> 24) & 0xff).toString(16).padStart(2, '0');

    return { success: true, txHex };
  } catch (err) {
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Failed to extract transaction'
    };
  }
}

// ============================================================================
// Helper Functions for Display
// ============================================================================

/**
 * Format sighash type for human-readable display
 */
function formatSighashType(sighashType) {
  const SIGHASH_ALL = 0x01;
  const SIGHASH_NONE = 0x02;
  const SIGHASH_SINGLE = 0x03;
  const SIGHASH_ANYONECANPAY = 0x80;

  const baseType = sighashType & 0x1f;
  const anyoneCanPay = (sighashType & SIGHASH_ANYONECANPAY) !== 0;

  let name;
  switch (baseType) {
    case SIGHASH_ALL:
      name = 'SIGHASH_ALL';
      break;
    case SIGHASH_NONE:
      name = 'SIGHASH_NONE';
      break;
    case SIGHASH_SINGLE:
      name = 'SIGHASH_SINGLE';
      break;
    default:
      name = `UNKNOWN(0x${baseType.toString(16)})`;
  }

  if (anyoneCanPay) {
    name += '|ANYONECANPAY';
  }

  return name;
}

// Public API
return {
  decodeTransaction: decodeTransaction,
  decodePSBT: decodePSBT,
  decodeAny: decodeAny,
  isPSBT: isPSBT,
  isValidTransactionHex: isValidTransactionHex,
  sanitizeHexInput: sanitizeHexInput,
  detectInputType: detectInputType,
  canFinalizePSBT: canFinalizePSBT,
  extractTransactionFromPSBT: extractTransactionFromPSBT,
  formatSighashType: formatSighashType,
  ByteReader: ByteReader
};
})();

</script>
<script>
(function() {
'use strict';

var POOL_NAMES = {
  core: 'Bitcoin Core', knots: 'Bitcoin Knots', libre: 'Libre Relay',
  mempool_space: 'mempool.space', blockstream: 'Blockstream', blockcypher: 'BlockCypher'
};

var siteName = window.location.host.replace(/^www\./, '');
document.getElementById('siteName').textContent = siteName;
document.getElementById('footerSiteName').textContent = siteName;
document.title = 'Broadcasting - ' + siteName;

var rawHex = window.location.pathname.slice(1);

if (!rawHex || rawHex.length < 164) {
  showError('Transaction hex must be at least 164 characters (82 bytes). Got ' + (rawHex ? rawHex.length : 0) + ' characters.');
  return;
}
if (!/^[0-9a-fA-F]+$/.test(rawHex)) {
  showError('Invalid characters in transaction hex. Only 0-9 and a-f are allowed.');
  return;
}
if (rawHex.length % 2 !== 0) {
  showError('Transaction hex has odd length (' + rawHex.length + '). Must be even.');
  return;
}

var txid = null;
var attempt = 0;
var maxAttempts = 15;
var baseDelay = 500;

function detectChainFromAddress(addr) {
  if (!addr) return null;
  if (addr.startsWith('bcrt1')) return 'regtest';
  if (addr.startsWith('tb1')) return 'testnet';
  if (addr.startsWith('bc1')) return 'mainnet';
  if ('mn2'.includes(addr[0])) return 'testnet';
  if ('13'.includes(addr[0])) return 'mainnet';
  return null;
}

var chainBannerColors = {
  regtest: { bg: 'rgba(5,150,105,0.15)', border: 'rgba(5,150,105,0.4)', color: '#34d399' },
  testnet: { bg: 'rgba(124,58,237,0.15)', border: 'rgba(124,58,237,0.4)', color: '#a78bfa' },
  signet:  { bg: 'rgba(37,99,235,0.15)', border: 'rgba(37,99,235,0.4)', color: '#60a5fa' },
  mainnet: { bg: 'rgba(247,147,26,0.15)', border: 'rgba(247,147,26,0.4)', color: '#f7931a' }
};

function updateChainDetectBanner(outputs) {
  var banner = document.getElementById('chain-detect-banner');
  if (!banner || !outputs || outputs.length === 0) { if (banner) banner.style.display = 'none'; return; }
  var detected = null;
  var sample = '';
  for (var i = 0; i < outputs.length; i++) {
    var addr = outputs[i].address;
    if (!addr) continue;
    var chain = detectChainFromAddress(addr);
    if (chain) { detected = chain; sample = addr.length > 12 ? addr.slice(0, 12) + '...' : addr; break; }
  }
  if (!detected || detected === 'mainnet') { banner.style.display = 'none'; return; }
  var c = chainBannerColors[detected] || chainBannerColors.testnet;
  var label = detected.toUpperCase();
  banner.style.display = 'block';
  banner.style.background = c.bg;
  banner.style.border = '1px solid ' + c.border;
  banner.style.color = c.color;
  banner.textContent = 'This transaction targets ' + label + ' \u2014 outputs contain ' + sample + ' addresses';
}

init();

async function init() {
  try {
    if (typeof TxDecoder === 'undefined') {
      showError('Transaction decoder not loaded.');
      return;
    }
    var result = await TxDecoder.decodeAny(rawHex);
    if (result.type === 'transaction') {
      txid = result.data.txid;
    } else if (result.type === 'psbt') {
      txid = result.data.unsignedTx.txid;
    }
    renderPreview(result);
    var outputs = result.type === 'psbt' ? (result.data.unsignedTx && result.data.unsignedTx.outputs || []) : (result.data.outputs || []);
    updateChainDetectBanner(outputs);
    if (txid) setTimeout(poll, baseDelay);
  } catch (err) {
    console.error('Decode error:', err);
    setTimeout(poll, baseDelay);
  }
}

function showError(msg) {
  document.getElementById('statusSection').style.display = 'none';
  document.getElementById('errorSection').style.display = 'flex';
  document.getElementById('errorMessage').textContent = msg;
}

async function poll() {
  attempt++;
  document.getElementById('statusSub').textContent =
    'Submitting to network endpoints... (attempt ' + attempt + '/' + maxAttempts + ')';

  if (!txid) {
    if (attempt >= maxAttempts) return;
    setTimeout(poll, Math.min(baseDelay * Math.pow(1.5, attempt - 1), 5000));
    return;
  }

  try {
    var resp = await fetch('/tx/' + txid, { headers: { 'Accept': 'application/json' } });
    if (resp.ok) {
      showResult(await resp.json());
      return;
    }
  } catch (e) { /* not ready */ }

  if (attempt >= maxAttempts) {
    window.location.href = '/tx/' + txid;
    return;
  }
  setTimeout(poll, Math.min(baseDelay * Math.pow(1.5, attempt - 1), 5000));
}

function showResult(data) {
  var success = data.success;
  var iconEl = document.getElementById('statusIcon');
  var titleEl = document.getElementById('statusTitle');
  var subEl = document.getElementById('statusSub');
  var linksEl = document.getElementById('statusLinks');

  iconEl.innerHTML = success
    ? '<svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="#22c55e" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>'
    : '<svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="#ef4444" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>';
  iconEl.className = 'status-icon';
  titleEl.textContent = success ? 'Broadcast Successful' : 'Broadcast Failed';

  var tid = data.txid || '';
  subEl.innerHTML = tid ? '<span class="badge badge-muted mono" style="font-size:12px">' + esc(tid) + '</span>' : '';

  linksEl.style.display = 'flex';
  var lh = '';
  if (tid) {
    lh += '<a href="/tx/' + tid + '" style="font-size:14px;color:#f7931a">View full result</a>';
    lh += '<a href="https://mempool.space/tx/' + tid + '" target="_blank" rel="noopener" style="display:inline-flex;align-items:center;gap:4px;font-size:14px;color:#a0a0a0"><svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>mempool.space</a>';
  }
  linksEl.innerHTML = lh;

  // Result summary
  var rs = document.getElementById('resultSection');
  rs.style.display = 'block';
  var accepted = data.meta ? data.meta.endpoints_accepted : 0;
  var tried = data.meta ? data.meta.endpoints_attempted : 0;
  var timeMs = data.meta ? data.meta.processing_time_ms : 0;
  document.getElementById('resultGrid').innerHTML =
    '<div class="result-item"><div class="result-label">Status</div><div class="result-value"><span class="badge ' + (success ? 'badge-success' : 'badge-error') + '">' + (success ? 'Accepted' : 'Rejected') + '</span></div></div>' +
    '<div class="result-item"><div class="result-label">Endpoints Tried</div><div class="result-value">' + tried + '</div></div>' +
    '<div class="result-item"><div class="result-label">Accepted By</div><div class="result-value">' + accepted + '</div></div>' +
    '<div class="result-item"><div class="result-label">Time</div><div class="result-value">' + timeMs + 'ms</div></div>';

  // Endpoints
  if (data.broadcast_results) {
    document.getElementById('endpointSection').style.display = 'block';
    var br = data.broadcast_results;
    var keys = Object.keys(br);
    var ac = keys.filter(function(k) { return br[k].success; }).length;
    var pct = keys.length > 0 ? Math.round((ac / keys.length) * 100) : 0;

    document.getElementById('acceptanceBar').innerHTML =
      '<div style="display:flex;justify-content:space-between;font-size:12px;color:#888;margin-bottom:4px"><span>' + ac + '/' + keys.length + ' accepted</span><span>' + pct + '%</span></div>' +
      '<div class="acceptance-bar"><div class="acceptance-fill" style="width:' + pct + '%;background:' + (pct >= 80 ? '#22c55e' : pct >= 60 ? '#84cc16' : pct >= 40 ? '#eab308' : pct >= 20 ? '#f97316' : '#ef4444') + '"></div></div>';

    var el = '';
    keys.forEach(function(k) {
      var r = br[k];
      var nm = POOL_NAMES[k] || k;
      var ic = r.success
        ? '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#22c55e" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>'
        : '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#ef4444" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>';
      var det = !r.success && r.error ? '<span style="color:#888;font-size:11px;margin-left:8px">' + esc(r.error) + '</span>' : '';
      var tm = r.time_ms ? '<span class="endpoint-time">' + r.time_ms + ' ms</span>' : '';
      el += '<div class="endpoint-row"><div class="endpoint-name">' + ic + ' <span style="color:' + (r.success ? '#fff' : '#888') + '">' + esc(nm) + '</span>' + det + '</div>' + tm + '</div>';
    });
    document.getElementById('endpointList').innerHTML = el;
  }
}

function esc(s) {
  if (!s) return '';
  var d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

function copyText(text, btn) {
  navigator.clipboard.writeText(text).then(function() {
    btn.classList.add('copied');
    var o = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(function() { btn.textContent = o; btn.classList.remove('copied'); }, 2000);
  });
}

// ============================================================================
// Transaction Preview
// ============================================================================

function renderPreview(decodeResult) {
  var c = document.getElementById('txPreview');
  document.getElementById('txPreviewSection').style.display = 'block';
  if (decodeResult.type === 'transaction') renderTx(c, decodeResult.data);
  else if (decodeResult.type === 'psbt') renderPsbt(c, decodeResult.data);
}

function renderTx(c, tx) {
  var h = '<div class="tx-preview">';

  if (tx.warnings && tx.warnings.length > 0) {
    tx.warnings.forEach(function(w) {
      h += '<div class="warning-box"><svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="#eab308" stroke-width="2" style="flex-shrink:0"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><span class="warning-text">' + esc(w) + '</span></div>';
    });
  }

  if (tx.nonStandardReport && !tx.nonStandardReport.isStandard) h += nsReport(tx.nonStandardReport);
  if (tx.detectedProtocols && tx.detectedProtocols.length > 0) h += protoBadges(tx.detectedProtocols);

  h += '<div class="tx-info-grid">';
  h += '<div><div class="tx-label">TXID</div><div class="tx-value" style="font-size:11px">' + tx.txid.slice(0, 16) + '\u2026 <button class="copy-btn" onclick="copyText(\'' + tx.txid + '\',this)">Copy</button></div></div>';
  h += '<div><div class="tx-label">Version</div><div class="tx-value">' + tx.version + '</div></div>';
  h += '<div><div class="tx-label">Size</div><div class="tx-value">' + tx.vsize + ' vB (' + tx.size + ' B)</div></div>';
  h += '<div><div class="tx-label">Weight</div><div class="tx-value">' + tx.weight + ' WU</div></div>';
  h += '</div>';

  h += '<div class="tx-badges">';
  if (tx.isSegwit) h += '<span class="badge badge-info">SegWit</span>';
  if (tx.isRbfSignaled) h += '<span class="badge badge-warning">RBF</span>';
  if (tx.hasOpReturn) h += '<span class="badge badge-muted">OP_RETURN x' + tx.opReturnCount + '</span>';
  if (tx.locktime > 0) h += '<span class="badge badge-muted">Locktime: ' + esc(tx.locktimeValue) + '</span>';
  h += '</div>';

  h += expandSection('Inputs (' + tx.inputs.length + ')', 'inp', function() {
    var r = '';
    tx.inputs.forEach(function(inp, i) { r += inputRow(inp, i); });
    return r;
  }, true);

  h += expandSection('Outputs (' + tx.outputs.length + ')', 'out', function() {
    var r = '';
    tx.outputs.forEach(function(out, i) { r += outputRow(out, i); });
    r += '<div class="tx-row" style="font-weight:600;color:#fff"><div style="display:flex;justify-content:space-between"><span>Total</span><span>' + btc(tx.totalOutputSats) + ' BTC</span></div></div>';
    return r;
  }, true);

  h += '</div>';
  c.innerHTML = h;
  bindExp(c);
}

function renderPsbt(c, psbt) {
  var h = '<div class="tx-preview">';
  var sc = psbt.isFullySigned ? '#22c55e' : '#eab308';
  h += '<div style="padding:16px;border-bottom:1px solid #333;display:flex;align-items:center;gap:12px">';
  h += '<div style="width:20px;height:20px;color:' + sc + '">&#128274;</div>';
  h += '<div><div style="font-weight:600;color:' + sc + '">' + (psbt.isFullySigned ? 'Fully Signed' : 'Partially Signed') + '</div>';
  h += '<div style="font-size:12px;color:#888">' + psbt.signingProgress + '</div></div></div>';

  // PSBT Extract Raw TX button or cannot-extract message
  if (psbt.isFullySigned) {
    var extractId = 'extract-' + Math.random().toString(36).slice(2,8);
    h += '<div style="padding:12px 16px;border-bottom:1px solid #333">';
    h += '<button onclick="handleExtractRawTx(this,\'' + extractId + '\')" style="display:inline-flex;align-items:center;gap:8px;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:600;background:#22c55e;color:#0f0f0f;border:none;cursor:pointer">';
    h += '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
    h += ' Extract Raw TX</button>';
    h += '<div id="' + extractId + '" style="display:none;margin-top:12px"></div>';
    h += '</div>';
  } else {
    var finCheck = TxDecoder.canFinalizePSBT(psbt);
    if (!finCheck.canFinalize) {
      h += '<div style="display:flex;align-items:center;gap:8px;padding:12px 16px;border-bottom:1px solid #333">';
      h += '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#666" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>';
      h += '<span style="font-size:13px;color:#888">Cannot extract transaction: ' + esc(finCheck.reason || 'Not all inputs are signed') + '</span>';
      h += '</div>';
    }
  }

  if (psbt.fee !== undefined) {
    h += '<div class="tx-info-grid">';
    h += '<div><div class="tx-label">Fee</div><div class="tx-value">' + psbt.feeBtc + ' BTC</div></div>';
    h += '<div><div class="tx-label">Fee Rate</div><div class="tx-value">' + (psbt.feeRate || '?') + ' sat/vB</div></div>';
    h += '<div><div class="tx-label">Input Total</div><div class="tx-value">' + psbt.totalInputBtc + ' BTC</div></div>';
    h += '<div><div class="tx-label">Output Total</div><div class="tx-value">' + psbt.totalOutputBtc + ' BTC</div></div>';
    h += '</div>';
  }

  var utx = psbt.unsignedTx;
  h += expandSection('Inputs (' + utx.inputs.length + ')', 'pinp', function() {
    var r = '';
    utx.inputs.forEach(function(inp, i) {
      r += inputRow(inp, i);
      var pi = psbt.inputs[i];
      if (pi) {
        var m = '';
        if (pi.witnessUtxo) m += '<div style="font-size:12px;color:#888;padding:4px 16px">UTXO: ' + pi.witnessUtxo.valueBtc + ' BTC (' + (pi.witnessUtxo.address || pi.witnessUtxo.scriptType) + ')</div>';
        if (pi.partialSigs.length > 0) m += '<div style="font-size:12px;color:#888;padding:4px 16px">Partial Sigs: ' + pi.partialSigs.length + '</div>';
        if (pi.bip32Derivation.length > 0) m += '<div style="font-size:12px;color:#888;padding:4px 16px">BIP32: ' + pi.bip32Derivation.map(function(d) { return d.path; }).join(', ') + '</div>';
        r += m;
      }
    });
    return r;
  }, true);

  h += expandSection('Outputs (' + utx.outputs.length + ')', 'pout', function() {
    var r = '';
    utx.outputs.forEach(function(out, i) { r += outputRow(out, i); });
    return r;
  }, true);

  h += '</div>';
  c.innerHTML = h;
  bindExp(c);
}

function expandSection(title, id, contentFn, open) {
  var chD = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>';
  var chR = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>';
  return '<div class="tx-section-header" data-exp="' + id + '"><span class="section-title">' + title + '</span><span class="exp-icon">' + (open ? chD : chR) + '</span></div>' +
    '<div class="expandable-content' + (open ? ' open' : '') + '" data-exp-t="' + id + '">' + contentFn() + '</div>';
}

function inputRow(inp, i) {
  return '<div class="tx-row"><div style="display:flex;align-items:center;justify-content:space-between">' +
    '<div style="display:flex;align-items:center;gap:8px"><span class="badge badge-muted" style="font-size:11px">#' + i + '</span>' +
    '<span class="mono" style="font-size:11px;color:#a0a0a0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:200px">' + inp.txid + ':' + inp.vout + '</span></div>' +
    '<div style="display:flex;align-items:center;gap:6px">' +
    (inp.isRbfEnabled ? '<span class="badge badge-warning" style="font-size:10px">RBF</span>' : '') +
    '<span style="font-size:11px;color:#666">seq: 0x' + inp.sequence.toString(16) + '</span></div></div></div>';
}

function outputRow(out, i) {
  var addr = '';
  if (out.address) addr = '<span class="mono" style="font-size:11px;color:#a0a0a0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:200px">' + esc(out.address) + '</span>';
  else if (out.scriptType === 'op_return') addr = '<span class="badge badge-muted" style="font-size:10px">OP_RETURN</span>' + (out.opReturnData ? '<span style="font-size:11px;color:#888;margin-left:4px">' + esc(out.opReturnData.ascii.slice(0, 40)) + '</span>' : '');
  else addr = '<span style="font-size:11px;color:#888">' + fmtType(out.scriptType) + '</span>';

  return '<div class="tx-row"><div style="display:flex;align-items:center;justify-content:space-between">' +
    '<div style="display:flex;align-items:center;gap:8px"><span class="badge badge-muted" style="font-size:11px">#' + i + '</span>' + addr + '</div>' +
    '<span class="mono" style="font-size:12px;color:#fff;font-weight:600">' + out.valueBtc + ' BTC</span></div></div>';
}

function protoBadges(protocols) {
  var colors = { ordinals:'#f97316', brc20:'#eab308', runes:'#8b5cf6', cat21:'#10b981', atomicals:'#0ea5e9', stamps:'#ec4899', counterparty:'#06b6d4' };
  var labels = { ordinals:'Ordinals', brc20:'BRC-20', runes:'Runes', cat21:'CAT-21', atomicals:'Atomicals', stamps:'Stamps', counterparty:'Counterparty' };
  var h = '<div style="padding:8px 16px;display:flex;flex-wrap:wrap;gap:6px;border-bottom:1px solid #333">';
  protocols.forEach(function(p) {
    var cl = colors[p.type] || '#888';
    h += '<span class="protocol-badge" style="background:' + cl + '20;color:' + cl + ';border:1px solid ' + cl + '40">' + (labels[p.type] || p.type) + '</span>';
  });
  h += '</div>';

  // Protocol detail sections
  protocols.forEach(function(p) {
    var cl = colors[p.type] || '#888';
    var lb = labels[p.type] || p.type;
    var details = '';
    if (p.type === 'ordinals' && p.inscription) {
      var ins = p.inscription;
      details += pDetail('Content Type', ins.contentType || 'unknown');
      details += pDetail('Content Length', (ins.contentLength || 0) + ' bytes');
      if (ins.parent) details += pDetail('Parent', ins.parent);
      if (ins.pointer !== undefined) details += pDetail('Pointer', String(ins.pointer));
      if (ins.metaprotocol) details += pDetail('Metaprotocol', ins.metaprotocol);
      if (ins.contentPreview) details += '<div style="margin-top:4px"><span style="font-size:11px;color:#666">Content Preview:</span><code style="display:block;margin-top:4px;font-size:10px;color:#a0a0a0;word-break:break-all;background:#252525;padding:6px;border-radius:4px;max-height:80px;overflow-y:auto">' + esc(ins.contentPreview) + '</code></div>';
    } else if (p.type === 'brc20' && p.details) {
      if (p.operation) details += pDetail('Operation', p.operation);
      if (p.details.tick) details += pDetail('Tick', p.details.tick);
      if (p.details.amt) details += pDetail('Amount', p.details.amt);
      if (p.details.max) details += pDetail('Max', p.details.max);
      if (p.details.lim) details += pDetail('Limit', p.details.lim);
      if (p.details.dec) details += pDetail('Decimals', p.details.dec);
    } else if (p.type === 'runes' && p.details) {
      var d = p.details;
      if (d.type) details += pDetail('Type', d.type);
      if (d.spacedName) details += pDetail('Name', d.spacedName);
      if (d.symbol) details += pDetail('Symbol', d.symbol);
      if (d.divisibility !== undefined) details += pDetail('Divisibility', String(d.divisibility));
      if (d.turbo) details += pDetail('Turbo', 'Yes');
      if (d.premine) details += pDetail('Premine', String(d.premine));
      if (d.supply) details += pDetail('Supply', String(d.supply));
      if (d.edicts && d.edicts.length > 0) details += pDetail('Edicts', String(d.edicts.length));
    } else if (p.type === 'cat21' && p.details) {
      if (p.details.type) details += pDetail('Type', p.details.type);
      if (p.details.catId) details += pDetail('Cat ID', p.details.catId);
    } else if (p.type === 'atomicals' && p.details) {
      if (p.details.type) details += pDetail('Type', p.details.type);
      if (p.details.realm) details += pDetail('Realm', p.details.realm);
      if (p.details.container) details += pDetail('Container', p.details.container);
    }
    if (details) {
      h += '<div style="padding:8px 16px;border-bottom:1px solid #333"><div style="padding:8px;border-radius:6px;background:' + cl + '10;border:1px solid ' + cl + '30">';
      h += '<div style="font-size:12px;font-weight:600;color:' + cl + ';margin-bottom:6px">' + esc(lb) + ' Details</div>';
      h += details + '</div></div>';
    }
  });

  return h;
}

function pDetail(label, value) {
  return '<div style="display:flex;justify-content:space-between;font-size:11px;margin-bottom:4px"><span style="color:#666">' + esc(label) + '</span><span style="color:#a0a0a0">' + esc(value) + '</span></div>';
}

function nsReport(report) {
  var h = '<div style="padding:12px 16px;border-bottom:1px solid #333;background:rgba(239,68,68,.05)">';
  h += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;font-size:13px;font-weight:600;color:#ef4444">' + esc(report.summary) + '</div>';
  report.checks.forEach(function(ck) {
    var cl = ck.severity === 'error' ? '#ef4444' : '#eab308';
    h += '<div class="ns-check"><span style="color:' + cl + ';font-weight:600;font-size:11px">' + (ck.severity === 'error' ? 'ERR' : 'WARN') + '</span><div><div style="color:#e0e0e0">' + esc(ck.message) + '</div>';
    if (ck.details) h += '<div class="ns-detail">' + esc(ck.details) + '</div>';
    if (ck.limit || ck.actual) h += '<div class="ns-limits">' + (ck.limit ? '<span>Limit: ' + esc(ck.limit) + '</span>' : '') + (ck.actual ? '<span>Actual: ' + esc(ck.actual) + '</span>' : '') + '</div>';
    h += '</div></div>';
  });
  return h + '</div>';
}

function fmtType(t) {
  return { p2pkh:'P2PKH', p2sh:'P2SH', p2wpkh:'P2WPKH', p2wsh:'P2WSH', p2tr:'P2TR', p2pk:'P2PK', multisig:'Multisig', op_return:'OP_RETURN', unknown:'Unknown' }[t] || t;
}

function btc(sats) { return (sats / 100000000).toFixed(8); }

function bindExp(container) {
  container.querySelectorAll('[data-exp]').forEach(function(el) {
    el.addEventListener('click', function() {
      var id = el.getAttribute('data-exp');
      var tgt = container.querySelector('[data-exp-t="' + id + '"]');
      var icon = el.querySelector('.exp-icon');
      if (tgt) {
        tgt.classList.toggle('open');
        icon.innerHTML = tgt.classList.contains('open')
          ? '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>'
          : '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>';
      }
    });
  });
}

})();

// Extract raw TX from finalized PSBT
function handleExtractRawTx(btn, containerId) {
  var container = document.getElementById(containerId);
  if (!container) return;
  // Get the current PSBT hex from the URL
  var hex = window.location.pathname.substring(1);
  if (!hex) return;
  TxDecoder.decodeAny(hex).then(function(result) {
    if (result.type !== 'psbt') return;
    var extracted = TxDecoder.extractTransactionFromPSBT(result.data);
    if (extracted.success) {
      container.style.display = 'block';
      container.innerHTML = '<div style="background:#1a1a1a;border:1px solid #333;border-radius:8px;padding:12px">' +
        '<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">' +
        '<span style="font-size:13px;font-weight:600;color:#22c55e">Raw Transaction Hex</span>' +
        '<button onclick="navigator.clipboard.writeText(\'' + extracted.txHex + '\').then(function(){this.textContent=\'Copied!\'}.bind(this))" style="font-size:12px;color:#888;background:none;border:1px solid #333;border-radius:4px;padding:4px 8px;cursor:pointer">Copy</button>' +
        '</div>' +
        '<code style="display:block;font-size:11px;color:#a0a0a0;word-break:break-all;max-height:200px;overflow-y:auto">' + esc(extracted.txHex) + '</code>' +
        '</div>';
    } else {
      container.style.display = 'block';
      container.innerHTML = '<div style="background:rgba(239,68,68,0.1);border:1px solid rgba(239,68,68,0.3);border-radius:8px;padding:12px">' +
        '<span style="font-size:13px;color:#ef4444">' + esc(extracted.error) + '</span></div>';
    }
  }).catch(function(err) {
    container.style.display = 'block';
    container.innerHTML = '<div style="background:rgba(239,68,68,0.1);border:1px solid rgba(239,68,68,0.3);border-radius:8px;padding:12px">' +
      '<span style="font-size:13px;color:#ef4444">Error: ' + esc(err.message) + '</span></div>';
  });
}
</script>
</body>
</html>
